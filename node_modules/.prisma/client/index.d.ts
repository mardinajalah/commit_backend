
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model tbKategori
 * 
 */
export type tbKategori = $Result.DefaultSelection<Prisma.$tbKategoriPayload>
/**
 * Model tbBarang
 * 
 */
export type tbBarang = $Result.DefaultSelection<Prisma.$tbBarangPayload>
/**
 * Model tbSatuan
 * 
 */
export type tbSatuan = $Result.DefaultSelection<Prisma.$tbSatuanPayload>
/**
 * Model tbAnggota
 * 
 */
export type tbAnggota = $Result.DefaultSelection<Prisma.$tbAnggotaPayload>
/**
 * Model tbDetail_Pengurus
 * 
 */
export type tbDetail_Pengurus = $Result.DefaultSelection<Prisma.$tbDetail_PengurusPayload>
/**
 * Model tbPengurus
 * 
 */
export type tbPengurus = $Result.DefaultSelection<Prisma.$tbPengurusPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Petugas
 * 
 */
export type Petugas = $Result.DefaultSelection<Prisma.$PetugasPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const StatusAktif: {
  yes: 'yes',
  no: 'no'
};

export type StatusAktif = (typeof StatusAktif)[keyof typeof StatusAktif]


export const UserLevel: {
  admin: 'admin',
  kasir: 'kasir'
};

export type UserLevel = (typeof UserLevel)[keyof typeof UserLevel]

}

export type StatusAktif = $Enums.StatusAktif

export const StatusAktif: typeof $Enums.StatusAktif

export type UserLevel = $Enums.UserLevel

export const UserLevel: typeof $Enums.UserLevel

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more TbKategoris
 * const tbKategoris = await prisma.tbKategori.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more TbKategoris
   * const tbKategoris = await prisma.tbKategori.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.tbKategori`: Exposes CRUD operations for the **tbKategori** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TbKategoris
    * const tbKategoris = await prisma.tbKategori.findMany()
    * ```
    */
  get tbKategori(): Prisma.tbKategoriDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tbBarang`: Exposes CRUD operations for the **tbBarang** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TbBarangs
    * const tbBarangs = await prisma.tbBarang.findMany()
    * ```
    */
  get tbBarang(): Prisma.tbBarangDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tbSatuan`: Exposes CRUD operations for the **tbSatuan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TbSatuans
    * const tbSatuans = await prisma.tbSatuan.findMany()
    * ```
    */
  get tbSatuan(): Prisma.tbSatuanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tbAnggota`: Exposes CRUD operations for the **tbAnggota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TbAnggotas
    * const tbAnggotas = await prisma.tbAnggota.findMany()
    * ```
    */
  get tbAnggota(): Prisma.tbAnggotaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tbDetail_Pengurus`: Exposes CRUD operations for the **tbDetail_Pengurus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TbDetail_Penguruses
    * const tbDetail_Penguruses = await prisma.tbDetail_Pengurus.findMany()
    * ```
    */
  get tbDetail_Pengurus(): Prisma.tbDetail_PengurusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tbPengurus`: Exposes CRUD operations for the **tbPengurus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TbPenguruses
    * const tbPenguruses = await prisma.tbPengurus.findMany()
    * ```
    */
  get tbPengurus(): Prisma.tbPengurusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.petugas`: Exposes CRUD operations for the **Petugas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Petugases
    * const petugases = await prisma.petugas.findMany()
    * ```
    */
  get petugas(): Prisma.PetugasDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.4.1
   * Query Engine version: a9055b89e58b4b5bfb59600785423b1db3d0e75d
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    tbKategori: 'tbKategori',
    tbBarang: 'tbBarang',
    tbSatuan: 'tbSatuan',
    tbAnggota: 'tbAnggota',
    tbDetail_Pengurus: 'tbDetail_Pengurus',
    tbPengurus: 'tbPengurus',
    Supplier: 'Supplier',
    Petugas: 'Petugas'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "tbKategori" | "tbBarang" | "tbSatuan" | "tbAnggota" | "tbDetail_Pengurus" | "tbPengurus" | "supplier" | "petugas"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      tbKategori: {
        payload: Prisma.$tbKategoriPayload<ExtArgs>
        fields: Prisma.tbKategoriFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tbKategoriFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbKategoriPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tbKategoriFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbKategoriPayload>
          }
          findFirst: {
            args: Prisma.tbKategoriFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbKategoriPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tbKategoriFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbKategoriPayload>
          }
          findMany: {
            args: Prisma.tbKategoriFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbKategoriPayload>[]
          }
          create: {
            args: Prisma.tbKategoriCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbKategoriPayload>
          }
          createMany: {
            args: Prisma.tbKategoriCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tbKategoriDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbKategoriPayload>
          }
          update: {
            args: Prisma.tbKategoriUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbKategoriPayload>
          }
          deleteMany: {
            args: Prisma.tbKategoriDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tbKategoriUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tbKategoriUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbKategoriPayload>
          }
          aggregate: {
            args: Prisma.TbKategoriAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTbKategori>
          }
          groupBy: {
            args: Prisma.tbKategoriGroupByArgs<ExtArgs>
            result: $Utils.Optional<TbKategoriGroupByOutputType>[]
          }
          count: {
            args: Prisma.tbKategoriCountArgs<ExtArgs>
            result: $Utils.Optional<TbKategoriCountAggregateOutputType> | number
          }
        }
      }
      tbBarang: {
        payload: Prisma.$tbBarangPayload<ExtArgs>
        fields: Prisma.tbBarangFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tbBarangFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbBarangPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tbBarangFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbBarangPayload>
          }
          findFirst: {
            args: Prisma.tbBarangFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbBarangPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tbBarangFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbBarangPayload>
          }
          findMany: {
            args: Prisma.tbBarangFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbBarangPayload>[]
          }
          create: {
            args: Prisma.tbBarangCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbBarangPayload>
          }
          createMany: {
            args: Prisma.tbBarangCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tbBarangDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbBarangPayload>
          }
          update: {
            args: Prisma.tbBarangUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbBarangPayload>
          }
          deleteMany: {
            args: Prisma.tbBarangDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tbBarangUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tbBarangUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbBarangPayload>
          }
          aggregate: {
            args: Prisma.TbBarangAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTbBarang>
          }
          groupBy: {
            args: Prisma.tbBarangGroupByArgs<ExtArgs>
            result: $Utils.Optional<TbBarangGroupByOutputType>[]
          }
          count: {
            args: Prisma.tbBarangCountArgs<ExtArgs>
            result: $Utils.Optional<TbBarangCountAggregateOutputType> | number
          }
        }
      }
      tbSatuan: {
        payload: Prisma.$tbSatuanPayload<ExtArgs>
        fields: Prisma.tbSatuanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tbSatuanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbSatuanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tbSatuanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbSatuanPayload>
          }
          findFirst: {
            args: Prisma.tbSatuanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbSatuanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tbSatuanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbSatuanPayload>
          }
          findMany: {
            args: Prisma.tbSatuanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbSatuanPayload>[]
          }
          create: {
            args: Prisma.tbSatuanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbSatuanPayload>
          }
          createMany: {
            args: Prisma.tbSatuanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tbSatuanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbSatuanPayload>
          }
          update: {
            args: Prisma.tbSatuanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbSatuanPayload>
          }
          deleteMany: {
            args: Prisma.tbSatuanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tbSatuanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tbSatuanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbSatuanPayload>
          }
          aggregate: {
            args: Prisma.TbSatuanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTbSatuan>
          }
          groupBy: {
            args: Prisma.tbSatuanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TbSatuanGroupByOutputType>[]
          }
          count: {
            args: Prisma.tbSatuanCountArgs<ExtArgs>
            result: $Utils.Optional<TbSatuanCountAggregateOutputType> | number
          }
        }
      }
      tbAnggota: {
        payload: Prisma.$tbAnggotaPayload<ExtArgs>
        fields: Prisma.tbAnggotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tbAnggotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbAnggotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tbAnggotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbAnggotaPayload>
          }
          findFirst: {
            args: Prisma.tbAnggotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbAnggotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tbAnggotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbAnggotaPayload>
          }
          findMany: {
            args: Prisma.tbAnggotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbAnggotaPayload>[]
          }
          create: {
            args: Prisma.tbAnggotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbAnggotaPayload>
          }
          createMany: {
            args: Prisma.tbAnggotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tbAnggotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbAnggotaPayload>
          }
          update: {
            args: Prisma.tbAnggotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbAnggotaPayload>
          }
          deleteMany: {
            args: Prisma.tbAnggotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tbAnggotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tbAnggotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbAnggotaPayload>
          }
          aggregate: {
            args: Prisma.TbAnggotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTbAnggota>
          }
          groupBy: {
            args: Prisma.tbAnggotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TbAnggotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.tbAnggotaCountArgs<ExtArgs>
            result: $Utils.Optional<TbAnggotaCountAggregateOutputType> | number
          }
        }
      }
      tbDetail_Pengurus: {
        payload: Prisma.$tbDetail_PengurusPayload<ExtArgs>
        fields: Prisma.tbDetail_PengurusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tbDetail_PengurusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbDetail_PengurusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tbDetail_PengurusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbDetail_PengurusPayload>
          }
          findFirst: {
            args: Prisma.tbDetail_PengurusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbDetail_PengurusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tbDetail_PengurusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbDetail_PengurusPayload>
          }
          findMany: {
            args: Prisma.tbDetail_PengurusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbDetail_PengurusPayload>[]
          }
          create: {
            args: Prisma.tbDetail_PengurusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbDetail_PengurusPayload>
          }
          createMany: {
            args: Prisma.tbDetail_PengurusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tbDetail_PengurusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbDetail_PengurusPayload>
          }
          update: {
            args: Prisma.tbDetail_PengurusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbDetail_PengurusPayload>
          }
          deleteMany: {
            args: Prisma.tbDetail_PengurusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tbDetail_PengurusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tbDetail_PengurusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbDetail_PengurusPayload>
          }
          aggregate: {
            args: Prisma.TbDetail_PengurusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTbDetail_Pengurus>
          }
          groupBy: {
            args: Prisma.tbDetail_PengurusGroupByArgs<ExtArgs>
            result: $Utils.Optional<TbDetail_PengurusGroupByOutputType>[]
          }
          count: {
            args: Prisma.tbDetail_PengurusCountArgs<ExtArgs>
            result: $Utils.Optional<TbDetail_PengurusCountAggregateOutputType> | number
          }
        }
      }
      tbPengurus: {
        payload: Prisma.$tbPengurusPayload<ExtArgs>
        fields: Prisma.tbPengurusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tbPengurusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbPengurusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tbPengurusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbPengurusPayload>
          }
          findFirst: {
            args: Prisma.tbPengurusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbPengurusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tbPengurusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbPengurusPayload>
          }
          findMany: {
            args: Prisma.tbPengurusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbPengurusPayload>[]
          }
          create: {
            args: Prisma.tbPengurusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbPengurusPayload>
          }
          createMany: {
            args: Prisma.tbPengurusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tbPengurusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbPengurusPayload>
          }
          update: {
            args: Prisma.tbPengurusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbPengurusPayload>
          }
          deleteMany: {
            args: Prisma.tbPengurusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tbPengurusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tbPengurusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tbPengurusPayload>
          }
          aggregate: {
            args: Prisma.TbPengurusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTbPengurus>
          }
          groupBy: {
            args: Prisma.tbPengurusGroupByArgs<ExtArgs>
            result: $Utils.Optional<TbPengurusGroupByOutputType>[]
          }
          count: {
            args: Prisma.tbPengurusCountArgs<ExtArgs>
            result: $Utils.Optional<TbPengurusCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Petugas: {
        payload: Prisma.$PetugasPayload<ExtArgs>
        fields: Prisma.PetugasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PetugasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetugasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PetugasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetugasPayload>
          }
          findFirst: {
            args: Prisma.PetugasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetugasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PetugasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetugasPayload>
          }
          findMany: {
            args: Prisma.PetugasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetugasPayload>[]
          }
          create: {
            args: Prisma.PetugasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetugasPayload>
          }
          createMany: {
            args: Prisma.PetugasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PetugasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetugasPayload>
          }
          update: {
            args: Prisma.PetugasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetugasPayload>
          }
          deleteMany: {
            args: Prisma.PetugasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PetugasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PetugasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetugasPayload>
          }
          aggregate: {
            args: Prisma.PetugasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePetugas>
          }
          groupBy: {
            args: Prisma.PetugasGroupByArgs<ExtArgs>
            result: $Utils.Optional<PetugasGroupByOutputType>[]
          }
          count: {
            args: Prisma.PetugasCountArgs<ExtArgs>
            result: $Utils.Optional<PetugasCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    tbKategori?: tbKategoriOmit
    tbBarang?: tbBarangOmit
    tbSatuan?: tbSatuanOmit
    tbAnggota?: tbAnggotaOmit
    tbDetail_Pengurus?: tbDetail_PengurusOmit
    tbPengurus?: tbPengurusOmit
    supplier?: SupplierOmit
    petugas?: PetugasOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TbKategoriCountOutputType
   */

  export type TbKategoriCountOutputType = {
    barang: number
  }

  export type TbKategoriCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barang?: boolean | TbKategoriCountOutputTypeCountBarangArgs
  }

  // Custom InputTypes
  /**
   * TbKategoriCountOutputType without action
   */
  export type TbKategoriCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TbKategoriCountOutputType
     */
    select?: TbKategoriCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TbKategoriCountOutputType without action
   */
  export type TbKategoriCountOutputTypeCountBarangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tbBarangWhereInput
  }


  /**
   * Count Type TbPengurusCountOutputType
   */

  export type TbPengurusCountOutputType = {
    detail_pengurus: number
  }

  export type TbPengurusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detail_pengurus?: boolean | TbPengurusCountOutputTypeCountDetail_pengurusArgs
  }

  // Custom InputTypes
  /**
   * TbPengurusCountOutputType without action
   */
  export type TbPengurusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TbPengurusCountOutputType
     */
    select?: TbPengurusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TbPengurusCountOutputType without action
   */
  export type TbPengurusCountOutputTypeCountDetail_pengurusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tbDetail_PengurusWhereInput
  }


  /**
   * Models
   */

  /**
   * Model tbKategori
   */

  export type AggregateTbKategori = {
    _count: TbKategoriCountAggregateOutputType | null
    _min: TbKategoriMinAggregateOutputType | null
    _max: TbKategoriMaxAggregateOutputType | null
  }

  export type TbKategoriMinAggregateOutputType = {
    kode_kategori: string | null
    nama: string | null
    aktif: $Enums.StatusAktif | null
  }

  export type TbKategoriMaxAggregateOutputType = {
    kode_kategori: string | null
    nama: string | null
    aktif: $Enums.StatusAktif | null
  }

  export type TbKategoriCountAggregateOutputType = {
    kode_kategori: number
    nama: number
    aktif: number
    _all: number
  }


  export type TbKategoriMinAggregateInputType = {
    kode_kategori?: true
    nama?: true
    aktif?: true
  }

  export type TbKategoriMaxAggregateInputType = {
    kode_kategori?: true
    nama?: true
    aktif?: true
  }

  export type TbKategoriCountAggregateInputType = {
    kode_kategori?: true
    nama?: true
    aktif?: true
    _all?: true
  }

  export type TbKategoriAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tbKategori to aggregate.
     */
    where?: tbKategoriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbKategoris to fetch.
     */
    orderBy?: tbKategoriOrderByWithRelationInput | tbKategoriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tbKategoriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbKategoris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbKategoris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tbKategoris
    **/
    _count?: true | TbKategoriCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TbKategoriMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TbKategoriMaxAggregateInputType
  }

  export type GetTbKategoriAggregateType<T extends TbKategoriAggregateArgs> = {
        [P in keyof T & keyof AggregateTbKategori]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTbKategori[P]>
      : GetScalarType<T[P], AggregateTbKategori[P]>
  }




  export type tbKategoriGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tbKategoriWhereInput
    orderBy?: tbKategoriOrderByWithAggregationInput | tbKategoriOrderByWithAggregationInput[]
    by: TbKategoriScalarFieldEnum[] | TbKategoriScalarFieldEnum
    having?: tbKategoriScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TbKategoriCountAggregateInputType | true
    _min?: TbKategoriMinAggregateInputType
    _max?: TbKategoriMaxAggregateInputType
  }

  export type TbKategoriGroupByOutputType = {
    kode_kategori: string
    nama: string
    aktif: $Enums.StatusAktif
    _count: TbKategoriCountAggregateOutputType | null
    _min: TbKategoriMinAggregateOutputType | null
    _max: TbKategoriMaxAggregateOutputType | null
  }

  type GetTbKategoriGroupByPayload<T extends tbKategoriGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TbKategoriGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TbKategoriGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TbKategoriGroupByOutputType[P]>
            : GetScalarType<T[P], TbKategoriGroupByOutputType[P]>
        }
      >
    >


  export type tbKategoriSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    kode_kategori?: boolean
    nama?: boolean
    aktif?: boolean
    barang?: boolean | tbKategori$barangArgs<ExtArgs>
    _count?: boolean | TbKategoriCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tbKategori"]>



  export type tbKategoriSelectScalar = {
    kode_kategori?: boolean
    nama?: boolean
    aktif?: boolean
  }

  export type tbKategoriOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"kode_kategori" | "nama" | "aktif", ExtArgs["result"]["tbKategori"]>
  export type tbKategoriInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barang?: boolean | tbKategori$barangArgs<ExtArgs>
    _count?: boolean | TbKategoriCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $tbKategoriPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tbKategori"
    objects: {
      barang: Prisma.$tbBarangPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      kode_kategori: string
      nama: string
      aktif: $Enums.StatusAktif
    }, ExtArgs["result"]["tbKategori"]>
    composites: {}
  }

  type tbKategoriGetPayload<S extends boolean | null | undefined | tbKategoriDefaultArgs> = $Result.GetResult<Prisma.$tbKategoriPayload, S>

  type tbKategoriCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tbKategoriFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TbKategoriCountAggregateInputType | true
    }

  export interface tbKategoriDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tbKategori'], meta: { name: 'tbKategori' } }
    /**
     * Find zero or one TbKategori that matches the filter.
     * @param {tbKategoriFindUniqueArgs} args - Arguments to find a TbKategori
     * @example
     * // Get one TbKategori
     * const tbKategori = await prisma.tbKategori.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tbKategoriFindUniqueArgs>(args: SelectSubset<T, tbKategoriFindUniqueArgs<ExtArgs>>): Prisma__tbKategoriClient<$Result.GetResult<Prisma.$tbKategoriPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TbKategori that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tbKategoriFindUniqueOrThrowArgs} args - Arguments to find a TbKategori
     * @example
     * // Get one TbKategori
     * const tbKategori = await prisma.tbKategori.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tbKategoriFindUniqueOrThrowArgs>(args: SelectSubset<T, tbKategoriFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tbKategoriClient<$Result.GetResult<Prisma.$tbKategoriPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TbKategori that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbKategoriFindFirstArgs} args - Arguments to find a TbKategori
     * @example
     * // Get one TbKategori
     * const tbKategori = await prisma.tbKategori.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tbKategoriFindFirstArgs>(args?: SelectSubset<T, tbKategoriFindFirstArgs<ExtArgs>>): Prisma__tbKategoriClient<$Result.GetResult<Prisma.$tbKategoriPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TbKategori that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbKategoriFindFirstOrThrowArgs} args - Arguments to find a TbKategori
     * @example
     * // Get one TbKategori
     * const tbKategori = await prisma.tbKategori.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tbKategoriFindFirstOrThrowArgs>(args?: SelectSubset<T, tbKategoriFindFirstOrThrowArgs<ExtArgs>>): Prisma__tbKategoriClient<$Result.GetResult<Prisma.$tbKategoriPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TbKategoris that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbKategoriFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TbKategoris
     * const tbKategoris = await prisma.tbKategori.findMany()
     * 
     * // Get first 10 TbKategoris
     * const tbKategoris = await prisma.tbKategori.findMany({ take: 10 })
     * 
     * // Only select the `kode_kategori`
     * const tbKategoriWithKode_kategoriOnly = await prisma.tbKategori.findMany({ select: { kode_kategori: true } })
     * 
     */
    findMany<T extends tbKategoriFindManyArgs>(args?: SelectSubset<T, tbKategoriFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tbKategoriPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TbKategori.
     * @param {tbKategoriCreateArgs} args - Arguments to create a TbKategori.
     * @example
     * // Create one TbKategori
     * const TbKategori = await prisma.tbKategori.create({
     *   data: {
     *     // ... data to create a TbKategori
     *   }
     * })
     * 
     */
    create<T extends tbKategoriCreateArgs>(args: SelectSubset<T, tbKategoriCreateArgs<ExtArgs>>): Prisma__tbKategoriClient<$Result.GetResult<Prisma.$tbKategoriPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TbKategoris.
     * @param {tbKategoriCreateManyArgs} args - Arguments to create many TbKategoris.
     * @example
     * // Create many TbKategoris
     * const tbKategori = await prisma.tbKategori.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tbKategoriCreateManyArgs>(args?: SelectSubset<T, tbKategoriCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TbKategori.
     * @param {tbKategoriDeleteArgs} args - Arguments to delete one TbKategori.
     * @example
     * // Delete one TbKategori
     * const TbKategori = await prisma.tbKategori.delete({
     *   where: {
     *     // ... filter to delete one TbKategori
     *   }
     * })
     * 
     */
    delete<T extends tbKategoriDeleteArgs>(args: SelectSubset<T, tbKategoriDeleteArgs<ExtArgs>>): Prisma__tbKategoriClient<$Result.GetResult<Prisma.$tbKategoriPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TbKategori.
     * @param {tbKategoriUpdateArgs} args - Arguments to update one TbKategori.
     * @example
     * // Update one TbKategori
     * const tbKategori = await prisma.tbKategori.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tbKategoriUpdateArgs>(args: SelectSubset<T, tbKategoriUpdateArgs<ExtArgs>>): Prisma__tbKategoriClient<$Result.GetResult<Prisma.$tbKategoriPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TbKategoris.
     * @param {tbKategoriDeleteManyArgs} args - Arguments to filter TbKategoris to delete.
     * @example
     * // Delete a few TbKategoris
     * const { count } = await prisma.tbKategori.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tbKategoriDeleteManyArgs>(args?: SelectSubset<T, tbKategoriDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TbKategoris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbKategoriUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TbKategoris
     * const tbKategori = await prisma.tbKategori.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tbKategoriUpdateManyArgs>(args: SelectSubset<T, tbKategoriUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TbKategori.
     * @param {tbKategoriUpsertArgs} args - Arguments to update or create a TbKategori.
     * @example
     * // Update or create a TbKategori
     * const tbKategori = await prisma.tbKategori.upsert({
     *   create: {
     *     // ... data to create a TbKategori
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TbKategori we want to update
     *   }
     * })
     */
    upsert<T extends tbKategoriUpsertArgs>(args: SelectSubset<T, tbKategoriUpsertArgs<ExtArgs>>): Prisma__tbKategoriClient<$Result.GetResult<Prisma.$tbKategoriPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TbKategoris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbKategoriCountArgs} args - Arguments to filter TbKategoris to count.
     * @example
     * // Count the number of TbKategoris
     * const count = await prisma.tbKategori.count({
     *   where: {
     *     // ... the filter for the TbKategoris we want to count
     *   }
     * })
    **/
    count<T extends tbKategoriCountArgs>(
      args?: Subset<T, tbKategoriCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TbKategoriCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TbKategori.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TbKategoriAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TbKategoriAggregateArgs>(args: Subset<T, TbKategoriAggregateArgs>): Prisma.PrismaPromise<GetTbKategoriAggregateType<T>>

    /**
     * Group by TbKategori.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbKategoriGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tbKategoriGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tbKategoriGroupByArgs['orderBy'] }
        : { orderBy?: tbKategoriGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tbKategoriGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTbKategoriGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tbKategori model
   */
  readonly fields: tbKategoriFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tbKategori.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tbKategoriClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    barang<T extends tbKategori$barangArgs<ExtArgs> = {}>(args?: Subset<T, tbKategori$barangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tbBarangPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tbKategori model
   */ 
  interface tbKategoriFieldRefs {
    readonly kode_kategori: FieldRef<"tbKategori", 'String'>
    readonly nama: FieldRef<"tbKategori", 'String'>
    readonly aktif: FieldRef<"tbKategori", 'StatusAktif'>
  }
    

  // Custom InputTypes
  /**
   * tbKategori findUnique
   */
  export type tbKategoriFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbKategori
     */
    select?: tbKategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbKategori
     */
    omit?: tbKategoriOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbKategoriInclude<ExtArgs> | null
    /**
     * Filter, which tbKategori to fetch.
     */
    where: tbKategoriWhereUniqueInput
  }

  /**
   * tbKategori findUniqueOrThrow
   */
  export type tbKategoriFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbKategori
     */
    select?: tbKategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbKategori
     */
    omit?: tbKategoriOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbKategoriInclude<ExtArgs> | null
    /**
     * Filter, which tbKategori to fetch.
     */
    where: tbKategoriWhereUniqueInput
  }

  /**
   * tbKategori findFirst
   */
  export type tbKategoriFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbKategori
     */
    select?: tbKategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbKategori
     */
    omit?: tbKategoriOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbKategoriInclude<ExtArgs> | null
    /**
     * Filter, which tbKategori to fetch.
     */
    where?: tbKategoriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbKategoris to fetch.
     */
    orderBy?: tbKategoriOrderByWithRelationInput | tbKategoriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbKategoris.
     */
    cursor?: tbKategoriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbKategoris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbKategoris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbKategoris.
     */
    distinct?: TbKategoriScalarFieldEnum | TbKategoriScalarFieldEnum[]
  }

  /**
   * tbKategori findFirstOrThrow
   */
  export type tbKategoriFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbKategori
     */
    select?: tbKategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbKategori
     */
    omit?: tbKategoriOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbKategoriInclude<ExtArgs> | null
    /**
     * Filter, which tbKategori to fetch.
     */
    where?: tbKategoriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbKategoris to fetch.
     */
    orderBy?: tbKategoriOrderByWithRelationInput | tbKategoriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbKategoris.
     */
    cursor?: tbKategoriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbKategoris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbKategoris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbKategoris.
     */
    distinct?: TbKategoriScalarFieldEnum | TbKategoriScalarFieldEnum[]
  }

  /**
   * tbKategori findMany
   */
  export type tbKategoriFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbKategori
     */
    select?: tbKategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbKategori
     */
    omit?: tbKategoriOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbKategoriInclude<ExtArgs> | null
    /**
     * Filter, which tbKategoris to fetch.
     */
    where?: tbKategoriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbKategoris to fetch.
     */
    orderBy?: tbKategoriOrderByWithRelationInput | tbKategoriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tbKategoris.
     */
    cursor?: tbKategoriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbKategoris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbKategoris.
     */
    skip?: number
    distinct?: TbKategoriScalarFieldEnum | TbKategoriScalarFieldEnum[]
  }

  /**
   * tbKategori create
   */
  export type tbKategoriCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbKategori
     */
    select?: tbKategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbKategori
     */
    omit?: tbKategoriOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbKategoriInclude<ExtArgs> | null
    /**
     * The data needed to create a tbKategori.
     */
    data: XOR<tbKategoriCreateInput, tbKategoriUncheckedCreateInput>
  }

  /**
   * tbKategori createMany
   */
  export type tbKategoriCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tbKategoris.
     */
    data: tbKategoriCreateManyInput | tbKategoriCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tbKategori update
   */
  export type tbKategoriUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbKategori
     */
    select?: tbKategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbKategori
     */
    omit?: tbKategoriOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbKategoriInclude<ExtArgs> | null
    /**
     * The data needed to update a tbKategori.
     */
    data: XOR<tbKategoriUpdateInput, tbKategoriUncheckedUpdateInput>
    /**
     * Choose, which tbKategori to update.
     */
    where: tbKategoriWhereUniqueInput
  }

  /**
   * tbKategori updateMany
   */
  export type tbKategoriUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tbKategoris.
     */
    data: XOR<tbKategoriUpdateManyMutationInput, tbKategoriUncheckedUpdateManyInput>
    /**
     * Filter which tbKategoris to update
     */
    where?: tbKategoriWhereInput
    /**
     * Limit how many tbKategoris to update.
     */
    limit?: number
  }

  /**
   * tbKategori upsert
   */
  export type tbKategoriUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbKategori
     */
    select?: tbKategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbKategori
     */
    omit?: tbKategoriOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbKategoriInclude<ExtArgs> | null
    /**
     * The filter to search for the tbKategori to update in case it exists.
     */
    where: tbKategoriWhereUniqueInput
    /**
     * In case the tbKategori found by the `where` argument doesn't exist, create a new tbKategori with this data.
     */
    create: XOR<tbKategoriCreateInput, tbKategoriUncheckedCreateInput>
    /**
     * In case the tbKategori was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tbKategoriUpdateInput, tbKategoriUncheckedUpdateInput>
  }

  /**
   * tbKategori delete
   */
  export type tbKategoriDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbKategori
     */
    select?: tbKategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbKategori
     */
    omit?: tbKategoriOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbKategoriInclude<ExtArgs> | null
    /**
     * Filter which tbKategori to delete.
     */
    where: tbKategoriWhereUniqueInput
  }

  /**
   * tbKategori deleteMany
   */
  export type tbKategoriDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tbKategoris to delete
     */
    where?: tbKategoriWhereInput
    /**
     * Limit how many tbKategoris to delete.
     */
    limit?: number
  }

  /**
   * tbKategori.barang
   */
  export type tbKategori$barangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbBarang
     */
    select?: tbBarangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbBarang
     */
    omit?: tbBarangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbBarangInclude<ExtArgs> | null
    where?: tbBarangWhereInput
    orderBy?: tbBarangOrderByWithRelationInput | tbBarangOrderByWithRelationInput[]
    cursor?: tbBarangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TbBarangScalarFieldEnum | TbBarangScalarFieldEnum[]
  }

  /**
   * tbKategori without action
   */
  export type tbKategoriDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbKategori
     */
    select?: tbKategoriSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbKategori
     */
    omit?: tbKategoriOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbKategoriInclude<ExtArgs> | null
  }


  /**
   * Model tbBarang
   */

  export type AggregateTbBarang = {
    _count: TbBarangCountAggregateOutputType | null
    _avg: TbBarangAvgAggregateOutputType | null
    _sum: TbBarangSumAggregateOutputType | null
    _min: TbBarangMinAggregateOutputType | null
    _max: TbBarangMaxAggregateOutputType | null
  }

  export type TbBarangAvgAggregateOutputType = {
    hargaBeli: number | null
    hargaEcer: number | null
    hargaGrosir: number | null
    stock: number | null
    stock_min: number | null
    ukuran: number | null
  }

  export type TbBarangSumAggregateOutputType = {
    hargaBeli: number | null
    hargaEcer: number | null
    hargaGrosir: number | null
    stock: number | null
    stock_min: number | null
    ukuran: number | null
  }

  export type TbBarangMinAggregateOutputType = {
    kode_barang: string | null
    nama_barang: string | null
    hargaBeli: number | null
    hargaEcer: number | null
    hargaGrosir: number | null
    stock: number | null
    stock_min: number | null
    barcode: string | null
    gambar: string | null
    kode_kategori: string | null
    ukuran: number | null
    satuan: string | null
    aktif: $Enums.StatusAktif | null
  }

  export type TbBarangMaxAggregateOutputType = {
    kode_barang: string | null
    nama_barang: string | null
    hargaBeli: number | null
    hargaEcer: number | null
    hargaGrosir: number | null
    stock: number | null
    stock_min: number | null
    barcode: string | null
    gambar: string | null
    kode_kategori: string | null
    ukuran: number | null
    satuan: string | null
    aktif: $Enums.StatusAktif | null
  }

  export type TbBarangCountAggregateOutputType = {
    kode_barang: number
    nama_barang: number
    hargaBeli: number
    hargaEcer: number
    hargaGrosir: number
    stock: number
    stock_min: number
    barcode: number
    gambar: number
    kode_kategori: number
    ukuran: number
    satuan: number
    aktif: number
    _all: number
  }


  export type TbBarangAvgAggregateInputType = {
    hargaBeli?: true
    hargaEcer?: true
    hargaGrosir?: true
    stock?: true
    stock_min?: true
    ukuran?: true
  }

  export type TbBarangSumAggregateInputType = {
    hargaBeli?: true
    hargaEcer?: true
    hargaGrosir?: true
    stock?: true
    stock_min?: true
    ukuran?: true
  }

  export type TbBarangMinAggregateInputType = {
    kode_barang?: true
    nama_barang?: true
    hargaBeli?: true
    hargaEcer?: true
    hargaGrosir?: true
    stock?: true
    stock_min?: true
    barcode?: true
    gambar?: true
    kode_kategori?: true
    ukuran?: true
    satuan?: true
    aktif?: true
  }

  export type TbBarangMaxAggregateInputType = {
    kode_barang?: true
    nama_barang?: true
    hargaBeli?: true
    hargaEcer?: true
    hargaGrosir?: true
    stock?: true
    stock_min?: true
    barcode?: true
    gambar?: true
    kode_kategori?: true
    ukuran?: true
    satuan?: true
    aktif?: true
  }

  export type TbBarangCountAggregateInputType = {
    kode_barang?: true
    nama_barang?: true
    hargaBeli?: true
    hargaEcer?: true
    hargaGrosir?: true
    stock?: true
    stock_min?: true
    barcode?: true
    gambar?: true
    kode_kategori?: true
    ukuran?: true
    satuan?: true
    aktif?: true
    _all?: true
  }

  export type TbBarangAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tbBarang to aggregate.
     */
    where?: tbBarangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbBarangs to fetch.
     */
    orderBy?: tbBarangOrderByWithRelationInput | tbBarangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tbBarangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbBarangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbBarangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tbBarangs
    **/
    _count?: true | TbBarangCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TbBarangAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TbBarangSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TbBarangMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TbBarangMaxAggregateInputType
  }

  export type GetTbBarangAggregateType<T extends TbBarangAggregateArgs> = {
        [P in keyof T & keyof AggregateTbBarang]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTbBarang[P]>
      : GetScalarType<T[P], AggregateTbBarang[P]>
  }




  export type tbBarangGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tbBarangWhereInput
    orderBy?: tbBarangOrderByWithAggregationInput | tbBarangOrderByWithAggregationInput[]
    by: TbBarangScalarFieldEnum[] | TbBarangScalarFieldEnum
    having?: tbBarangScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TbBarangCountAggregateInputType | true
    _avg?: TbBarangAvgAggregateInputType
    _sum?: TbBarangSumAggregateInputType
    _min?: TbBarangMinAggregateInputType
    _max?: TbBarangMaxAggregateInputType
  }

  export type TbBarangGroupByOutputType = {
    kode_barang: string
    nama_barang: string
    hargaBeli: number
    hargaEcer: number
    hargaGrosir: number
    stock: number
    stock_min: number
    barcode: string
    gambar: string
    kode_kategori: string
    ukuran: number
    satuan: string
    aktif: $Enums.StatusAktif
    _count: TbBarangCountAggregateOutputType | null
    _avg: TbBarangAvgAggregateOutputType | null
    _sum: TbBarangSumAggregateOutputType | null
    _min: TbBarangMinAggregateOutputType | null
    _max: TbBarangMaxAggregateOutputType | null
  }

  type GetTbBarangGroupByPayload<T extends tbBarangGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TbBarangGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TbBarangGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TbBarangGroupByOutputType[P]>
            : GetScalarType<T[P], TbBarangGroupByOutputType[P]>
        }
      >
    >


  export type tbBarangSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    kode_barang?: boolean
    nama_barang?: boolean
    hargaBeli?: boolean
    hargaEcer?: boolean
    hargaGrosir?: boolean
    stock?: boolean
    stock_min?: boolean
    barcode?: boolean
    gambar?: boolean
    kode_kategori?: boolean
    ukuran?: boolean
    satuan?: boolean
    aktif?: boolean
    kategori?: boolean | tbKategoriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tbBarang"]>



  export type tbBarangSelectScalar = {
    kode_barang?: boolean
    nama_barang?: boolean
    hargaBeli?: boolean
    hargaEcer?: boolean
    hargaGrosir?: boolean
    stock?: boolean
    stock_min?: boolean
    barcode?: boolean
    gambar?: boolean
    kode_kategori?: boolean
    ukuran?: boolean
    satuan?: boolean
    aktif?: boolean
  }

  export type tbBarangOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"kode_barang" | "nama_barang" | "hargaBeli" | "hargaEcer" | "hargaGrosir" | "stock" | "stock_min" | "barcode" | "gambar" | "kode_kategori" | "ukuran" | "satuan" | "aktif", ExtArgs["result"]["tbBarang"]>
  export type tbBarangInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kategori?: boolean | tbKategoriDefaultArgs<ExtArgs>
  }

  export type $tbBarangPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tbBarang"
    objects: {
      kategori: Prisma.$tbKategoriPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      kode_barang: string
      nama_barang: string
      hargaBeli: number
      hargaEcer: number
      hargaGrosir: number
      stock: number
      stock_min: number
      barcode: string
      gambar: string
      kode_kategori: string
      ukuran: number
      satuan: string
      aktif: $Enums.StatusAktif
    }, ExtArgs["result"]["tbBarang"]>
    composites: {}
  }

  type tbBarangGetPayload<S extends boolean | null | undefined | tbBarangDefaultArgs> = $Result.GetResult<Prisma.$tbBarangPayload, S>

  type tbBarangCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tbBarangFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TbBarangCountAggregateInputType | true
    }

  export interface tbBarangDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tbBarang'], meta: { name: 'tbBarang' } }
    /**
     * Find zero or one TbBarang that matches the filter.
     * @param {tbBarangFindUniqueArgs} args - Arguments to find a TbBarang
     * @example
     * // Get one TbBarang
     * const tbBarang = await prisma.tbBarang.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tbBarangFindUniqueArgs>(args: SelectSubset<T, tbBarangFindUniqueArgs<ExtArgs>>): Prisma__tbBarangClient<$Result.GetResult<Prisma.$tbBarangPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TbBarang that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tbBarangFindUniqueOrThrowArgs} args - Arguments to find a TbBarang
     * @example
     * // Get one TbBarang
     * const tbBarang = await prisma.tbBarang.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tbBarangFindUniqueOrThrowArgs>(args: SelectSubset<T, tbBarangFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tbBarangClient<$Result.GetResult<Prisma.$tbBarangPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TbBarang that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbBarangFindFirstArgs} args - Arguments to find a TbBarang
     * @example
     * // Get one TbBarang
     * const tbBarang = await prisma.tbBarang.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tbBarangFindFirstArgs>(args?: SelectSubset<T, tbBarangFindFirstArgs<ExtArgs>>): Prisma__tbBarangClient<$Result.GetResult<Prisma.$tbBarangPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TbBarang that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbBarangFindFirstOrThrowArgs} args - Arguments to find a TbBarang
     * @example
     * // Get one TbBarang
     * const tbBarang = await prisma.tbBarang.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tbBarangFindFirstOrThrowArgs>(args?: SelectSubset<T, tbBarangFindFirstOrThrowArgs<ExtArgs>>): Prisma__tbBarangClient<$Result.GetResult<Prisma.$tbBarangPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TbBarangs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbBarangFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TbBarangs
     * const tbBarangs = await prisma.tbBarang.findMany()
     * 
     * // Get first 10 TbBarangs
     * const tbBarangs = await prisma.tbBarang.findMany({ take: 10 })
     * 
     * // Only select the `kode_barang`
     * const tbBarangWithKode_barangOnly = await prisma.tbBarang.findMany({ select: { kode_barang: true } })
     * 
     */
    findMany<T extends tbBarangFindManyArgs>(args?: SelectSubset<T, tbBarangFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tbBarangPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TbBarang.
     * @param {tbBarangCreateArgs} args - Arguments to create a TbBarang.
     * @example
     * // Create one TbBarang
     * const TbBarang = await prisma.tbBarang.create({
     *   data: {
     *     // ... data to create a TbBarang
     *   }
     * })
     * 
     */
    create<T extends tbBarangCreateArgs>(args: SelectSubset<T, tbBarangCreateArgs<ExtArgs>>): Prisma__tbBarangClient<$Result.GetResult<Prisma.$tbBarangPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TbBarangs.
     * @param {tbBarangCreateManyArgs} args - Arguments to create many TbBarangs.
     * @example
     * // Create many TbBarangs
     * const tbBarang = await prisma.tbBarang.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tbBarangCreateManyArgs>(args?: SelectSubset<T, tbBarangCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TbBarang.
     * @param {tbBarangDeleteArgs} args - Arguments to delete one TbBarang.
     * @example
     * // Delete one TbBarang
     * const TbBarang = await prisma.tbBarang.delete({
     *   where: {
     *     // ... filter to delete one TbBarang
     *   }
     * })
     * 
     */
    delete<T extends tbBarangDeleteArgs>(args: SelectSubset<T, tbBarangDeleteArgs<ExtArgs>>): Prisma__tbBarangClient<$Result.GetResult<Prisma.$tbBarangPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TbBarang.
     * @param {tbBarangUpdateArgs} args - Arguments to update one TbBarang.
     * @example
     * // Update one TbBarang
     * const tbBarang = await prisma.tbBarang.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tbBarangUpdateArgs>(args: SelectSubset<T, tbBarangUpdateArgs<ExtArgs>>): Prisma__tbBarangClient<$Result.GetResult<Prisma.$tbBarangPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TbBarangs.
     * @param {tbBarangDeleteManyArgs} args - Arguments to filter TbBarangs to delete.
     * @example
     * // Delete a few TbBarangs
     * const { count } = await prisma.tbBarang.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tbBarangDeleteManyArgs>(args?: SelectSubset<T, tbBarangDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TbBarangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbBarangUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TbBarangs
     * const tbBarang = await prisma.tbBarang.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tbBarangUpdateManyArgs>(args: SelectSubset<T, tbBarangUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TbBarang.
     * @param {tbBarangUpsertArgs} args - Arguments to update or create a TbBarang.
     * @example
     * // Update or create a TbBarang
     * const tbBarang = await prisma.tbBarang.upsert({
     *   create: {
     *     // ... data to create a TbBarang
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TbBarang we want to update
     *   }
     * })
     */
    upsert<T extends tbBarangUpsertArgs>(args: SelectSubset<T, tbBarangUpsertArgs<ExtArgs>>): Prisma__tbBarangClient<$Result.GetResult<Prisma.$tbBarangPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TbBarangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbBarangCountArgs} args - Arguments to filter TbBarangs to count.
     * @example
     * // Count the number of TbBarangs
     * const count = await prisma.tbBarang.count({
     *   where: {
     *     // ... the filter for the TbBarangs we want to count
     *   }
     * })
    **/
    count<T extends tbBarangCountArgs>(
      args?: Subset<T, tbBarangCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TbBarangCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TbBarang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TbBarangAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TbBarangAggregateArgs>(args: Subset<T, TbBarangAggregateArgs>): Prisma.PrismaPromise<GetTbBarangAggregateType<T>>

    /**
     * Group by TbBarang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbBarangGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tbBarangGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tbBarangGroupByArgs['orderBy'] }
        : { orderBy?: tbBarangGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tbBarangGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTbBarangGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tbBarang model
   */
  readonly fields: tbBarangFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tbBarang.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tbBarangClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kategori<T extends tbKategoriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tbKategoriDefaultArgs<ExtArgs>>): Prisma__tbKategoriClient<$Result.GetResult<Prisma.$tbKategoriPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tbBarang model
   */ 
  interface tbBarangFieldRefs {
    readonly kode_barang: FieldRef<"tbBarang", 'String'>
    readonly nama_barang: FieldRef<"tbBarang", 'String'>
    readonly hargaBeli: FieldRef<"tbBarang", 'Int'>
    readonly hargaEcer: FieldRef<"tbBarang", 'Int'>
    readonly hargaGrosir: FieldRef<"tbBarang", 'Int'>
    readonly stock: FieldRef<"tbBarang", 'Int'>
    readonly stock_min: FieldRef<"tbBarang", 'Int'>
    readonly barcode: FieldRef<"tbBarang", 'String'>
    readonly gambar: FieldRef<"tbBarang", 'String'>
    readonly kode_kategori: FieldRef<"tbBarang", 'String'>
    readonly ukuran: FieldRef<"tbBarang", 'Int'>
    readonly satuan: FieldRef<"tbBarang", 'String'>
    readonly aktif: FieldRef<"tbBarang", 'StatusAktif'>
  }
    

  // Custom InputTypes
  /**
   * tbBarang findUnique
   */
  export type tbBarangFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbBarang
     */
    select?: tbBarangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbBarang
     */
    omit?: tbBarangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbBarangInclude<ExtArgs> | null
    /**
     * Filter, which tbBarang to fetch.
     */
    where: tbBarangWhereUniqueInput
  }

  /**
   * tbBarang findUniqueOrThrow
   */
  export type tbBarangFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbBarang
     */
    select?: tbBarangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbBarang
     */
    omit?: tbBarangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbBarangInclude<ExtArgs> | null
    /**
     * Filter, which tbBarang to fetch.
     */
    where: tbBarangWhereUniqueInput
  }

  /**
   * tbBarang findFirst
   */
  export type tbBarangFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbBarang
     */
    select?: tbBarangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbBarang
     */
    omit?: tbBarangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbBarangInclude<ExtArgs> | null
    /**
     * Filter, which tbBarang to fetch.
     */
    where?: tbBarangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbBarangs to fetch.
     */
    orderBy?: tbBarangOrderByWithRelationInput | tbBarangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbBarangs.
     */
    cursor?: tbBarangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbBarangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbBarangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbBarangs.
     */
    distinct?: TbBarangScalarFieldEnum | TbBarangScalarFieldEnum[]
  }

  /**
   * tbBarang findFirstOrThrow
   */
  export type tbBarangFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbBarang
     */
    select?: tbBarangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbBarang
     */
    omit?: tbBarangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbBarangInclude<ExtArgs> | null
    /**
     * Filter, which tbBarang to fetch.
     */
    where?: tbBarangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbBarangs to fetch.
     */
    orderBy?: tbBarangOrderByWithRelationInput | tbBarangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbBarangs.
     */
    cursor?: tbBarangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbBarangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbBarangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbBarangs.
     */
    distinct?: TbBarangScalarFieldEnum | TbBarangScalarFieldEnum[]
  }

  /**
   * tbBarang findMany
   */
  export type tbBarangFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbBarang
     */
    select?: tbBarangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbBarang
     */
    omit?: tbBarangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbBarangInclude<ExtArgs> | null
    /**
     * Filter, which tbBarangs to fetch.
     */
    where?: tbBarangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbBarangs to fetch.
     */
    orderBy?: tbBarangOrderByWithRelationInput | tbBarangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tbBarangs.
     */
    cursor?: tbBarangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbBarangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbBarangs.
     */
    skip?: number
    distinct?: TbBarangScalarFieldEnum | TbBarangScalarFieldEnum[]
  }

  /**
   * tbBarang create
   */
  export type tbBarangCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbBarang
     */
    select?: tbBarangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbBarang
     */
    omit?: tbBarangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbBarangInclude<ExtArgs> | null
    /**
     * The data needed to create a tbBarang.
     */
    data: XOR<tbBarangCreateInput, tbBarangUncheckedCreateInput>
  }

  /**
   * tbBarang createMany
   */
  export type tbBarangCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tbBarangs.
     */
    data: tbBarangCreateManyInput | tbBarangCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tbBarang update
   */
  export type tbBarangUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbBarang
     */
    select?: tbBarangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbBarang
     */
    omit?: tbBarangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbBarangInclude<ExtArgs> | null
    /**
     * The data needed to update a tbBarang.
     */
    data: XOR<tbBarangUpdateInput, tbBarangUncheckedUpdateInput>
    /**
     * Choose, which tbBarang to update.
     */
    where: tbBarangWhereUniqueInput
  }

  /**
   * tbBarang updateMany
   */
  export type tbBarangUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tbBarangs.
     */
    data: XOR<tbBarangUpdateManyMutationInput, tbBarangUncheckedUpdateManyInput>
    /**
     * Filter which tbBarangs to update
     */
    where?: tbBarangWhereInput
    /**
     * Limit how many tbBarangs to update.
     */
    limit?: number
  }

  /**
   * tbBarang upsert
   */
  export type tbBarangUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbBarang
     */
    select?: tbBarangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbBarang
     */
    omit?: tbBarangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbBarangInclude<ExtArgs> | null
    /**
     * The filter to search for the tbBarang to update in case it exists.
     */
    where: tbBarangWhereUniqueInput
    /**
     * In case the tbBarang found by the `where` argument doesn't exist, create a new tbBarang with this data.
     */
    create: XOR<tbBarangCreateInput, tbBarangUncheckedCreateInput>
    /**
     * In case the tbBarang was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tbBarangUpdateInput, tbBarangUncheckedUpdateInput>
  }

  /**
   * tbBarang delete
   */
  export type tbBarangDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbBarang
     */
    select?: tbBarangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbBarang
     */
    omit?: tbBarangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbBarangInclude<ExtArgs> | null
    /**
     * Filter which tbBarang to delete.
     */
    where: tbBarangWhereUniqueInput
  }

  /**
   * tbBarang deleteMany
   */
  export type tbBarangDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tbBarangs to delete
     */
    where?: tbBarangWhereInput
    /**
     * Limit how many tbBarangs to delete.
     */
    limit?: number
  }

  /**
   * tbBarang without action
   */
  export type tbBarangDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbBarang
     */
    select?: tbBarangSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbBarang
     */
    omit?: tbBarangOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbBarangInclude<ExtArgs> | null
  }


  /**
   * Model tbSatuan
   */

  export type AggregateTbSatuan = {
    _count: TbSatuanCountAggregateOutputType | null
    _min: TbSatuanMinAggregateOutputType | null
    _max: TbSatuanMaxAggregateOutputType | null
  }

  export type TbSatuanMinAggregateOutputType = {
    kode_satuan: string | null
    nama: string | null
    aktif: $Enums.StatusAktif | null
  }

  export type TbSatuanMaxAggregateOutputType = {
    kode_satuan: string | null
    nama: string | null
    aktif: $Enums.StatusAktif | null
  }

  export type TbSatuanCountAggregateOutputType = {
    kode_satuan: number
    nama: number
    aktif: number
    _all: number
  }


  export type TbSatuanMinAggregateInputType = {
    kode_satuan?: true
    nama?: true
    aktif?: true
  }

  export type TbSatuanMaxAggregateInputType = {
    kode_satuan?: true
    nama?: true
    aktif?: true
  }

  export type TbSatuanCountAggregateInputType = {
    kode_satuan?: true
    nama?: true
    aktif?: true
    _all?: true
  }

  export type TbSatuanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tbSatuan to aggregate.
     */
    where?: tbSatuanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbSatuans to fetch.
     */
    orderBy?: tbSatuanOrderByWithRelationInput | tbSatuanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tbSatuanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbSatuans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbSatuans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tbSatuans
    **/
    _count?: true | TbSatuanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TbSatuanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TbSatuanMaxAggregateInputType
  }

  export type GetTbSatuanAggregateType<T extends TbSatuanAggregateArgs> = {
        [P in keyof T & keyof AggregateTbSatuan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTbSatuan[P]>
      : GetScalarType<T[P], AggregateTbSatuan[P]>
  }




  export type tbSatuanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tbSatuanWhereInput
    orderBy?: tbSatuanOrderByWithAggregationInput | tbSatuanOrderByWithAggregationInput[]
    by: TbSatuanScalarFieldEnum[] | TbSatuanScalarFieldEnum
    having?: tbSatuanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TbSatuanCountAggregateInputType | true
    _min?: TbSatuanMinAggregateInputType
    _max?: TbSatuanMaxAggregateInputType
  }

  export type TbSatuanGroupByOutputType = {
    kode_satuan: string
    nama: string
    aktif: $Enums.StatusAktif
    _count: TbSatuanCountAggregateOutputType | null
    _min: TbSatuanMinAggregateOutputType | null
    _max: TbSatuanMaxAggregateOutputType | null
  }

  type GetTbSatuanGroupByPayload<T extends tbSatuanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TbSatuanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TbSatuanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TbSatuanGroupByOutputType[P]>
            : GetScalarType<T[P], TbSatuanGroupByOutputType[P]>
        }
      >
    >


  export type tbSatuanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    kode_satuan?: boolean
    nama?: boolean
    aktif?: boolean
  }, ExtArgs["result"]["tbSatuan"]>



  export type tbSatuanSelectScalar = {
    kode_satuan?: boolean
    nama?: boolean
    aktif?: boolean
  }

  export type tbSatuanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"kode_satuan" | "nama" | "aktif", ExtArgs["result"]["tbSatuan"]>

  export type $tbSatuanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tbSatuan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      kode_satuan: string
      nama: string
      aktif: $Enums.StatusAktif
    }, ExtArgs["result"]["tbSatuan"]>
    composites: {}
  }

  type tbSatuanGetPayload<S extends boolean | null | undefined | tbSatuanDefaultArgs> = $Result.GetResult<Prisma.$tbSatuanPayload, S>

  type tbSatuanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tbSatuanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TbSatuanCountAggregateInputType | true
    }

  export interface tbSatuanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tbSatuan'], meta: { name: 'tbSatuan' } }
    /**
     * Find zero or one TbSatuan that matches the filter.
     * @param {tbSatuanFindUniqueArgs} args - Arguments to find a TbSatuan
     * @example
     * // Get one TbSatuan
     * const tbSatuan = await prisma.tbSatuan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tbSatuanFindUniqueArgs>(args: SelectSubset<T, tbSatuanFindUniqueArgs<ExtArgs>>): Prisma__tbSatuanClient<$Result.GetResult<Prisma.$tbSatuanPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TbSatuan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tbSatuanFindUniqueOrThrowArgs} args - Arguments to find a TbSatuan
     * @example
     * // Get one TbSatuan
     * const tbSatuan = await prisma.tbSatuan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tbSatuanFindUniqueOrThrowArgs>(args: SelectSubset<T, tbSatuanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tbSatuanClient<$Result.GetResult<Prisma.$tbSatuanPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TbSatuan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbSatuanFindFirstArgs} args - Arguments to find a TbSatuan
     * @example
     * // Get one TbSatuan
     * const tbSatuan = await prisma.tbSatuan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tbSatuanFindFirstArgs>(args?: SelectSubset<T, tbSatuanFindFirstArgs<ExtArgs>>): Prisma__tbSatuanClient<$Result.GetResult<Prisma.$tbSatuanPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TbSatuan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbSatuanFindFirstOrThrowArgs} args - Arguments to find a TbSatuan
     * @example
     * // Get one TbSatuan
     * const tbSatuan = await prisma.tbSatuan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tbSatuanFindFirstOrThrowArgs>(args?: SelectSubset<T, tbSatuanFindFirstOrThrowArgs<ExtArgs>>): Prisma__tbSatuanClient<$Result.GetResult<Prisma.$tbSatuanPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TbSatuans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbSatuanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TbSatuans
     * const tbSatuans = await prisma.tbSatuan.findMany()
     * 
     * // Get first 10 TbSatuans
     * const tbSatuans = await prisma.tbSatuan.findMany({ take: 10 })
     * 
     * // Only select the `kode_satuan`
     * const tbSatuanWithKode_satuanOnly = await prisma.tbSatuan.findMany({ select: { kode_satuan: true } })
     * 
     */
    findMany<T extends tbSatuanFindManyArgs>(args?: SelectSubset<T, tbSatuanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tbSatuanPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TbSatuan.
     * @param {tbSatuanCreateArgs} args - Arguments to create a TbSatuan.
     * @example
     * // Create one TbSatuan
     * const TbSatuan = await prisma.tbSatuan.create({
     *   data: {
     *     // ... data to create a TbSatuan
     *   }
     * })
     * 
     */
    create<T extends tbSatuanCreateArgs>(args: SelectSubset<T, tbSatuanCreateArgs<ExtArgs>>): Prisma__tbSatuanClient<$Result.GetResult<Prisma.$tbSatuanPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TbSatuans.
     * @param {tbSatuanCreateManyArgs} args - Arguments to create many TbSatuans.
     * @example
     * // Create many TbSatuans
     * const tbSatuan = await prisma.tbSatuan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tbSatuanCreateManyArgs>(args?: SelectSubset<T, tbSatuanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TbSatuan.
     * @param {tbSatuanDeleteArgs} args - Arguments to delete one TbSatuan.
     * @example
     * // Delete one TbSatuan
     * const TbSatuan = await prisma.tbSatuan.delete({
     *   where: {
     *     // ... filter to delete one TbSatuan
     *   }
     * })
     * 
     */
    delete<T extends tbSatuanDeleteArgs>(args: SelectSubset<T, tbSatuanDeleteArgs<ExtArgs>>): Prisma__tbSatuanClient<$Result.GetResult<Prisma.$tbSatuanPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TbSatuan.
     * @param {tbSatuanUpdateArgs} args - Arguments to update one TbSatuan.
     * @example
     * // Update one TbSatuan
     * const tbSatuan = await prisma.tbSatuan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tbSatuanUpdateArgs>(args: SelectSubset<T, tbSatuanUpdateArgs<ExtArgs>>): Prisma__tbSatuanClient<$Result.GetResult<Prisma.$tbSatuanPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TbSatuans.
     * @param {tbSatuanDeleteManyArgs} args - Arguments to filter TbSatuans to delete.
     * @example
     * // Delete a few TbSatuans
     * const { count } = await prisma.tbSatuan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tbSatuanDeleteManyArgs>(args?: SelectSubset<T, tbSatuanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TbSatuans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbSatuanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TbSatuans
     * const tbSatuan = await prisma.tbSatuan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tbSatuanUpdateManyArgs>(args: SelectSubset<T, tbSatuanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TbSatuan.
     * @param {tbSatuanUpsertArgs} args - Arguments to update or create a TbSatuan.
     * @example
     * // Update or create a TbSatuan
     * const tbSatuan = await prisma.tbSatuan.upsert({
     *   create: {
     *     // ... data to create a TbSatuan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TbSatuan we want to update
     *   }
     * })
     */
    upsert<T extends tbSatuanUpsertArgs>(args: SelectSubset<T, tbSatuanUpsertArgs<ExtArgs>>): Prisma__tbSatuanClient<$Result.GetResult<Prisma.$tbSatuanPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TbSatuans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbSatuanCountArgs} args - Arguments to filter TbSatuans to count.
     * @example
     * // Count the number of TbSatuans
     * const count = await prisma.tbSatuan.count({
     *   where: {
     *     // ... the filter for the TbSatuans we want to count
     *   }
     * })
    **/
    count<T extends tbSatuanCountArgs>(
      args?: Subset<T, tbSatuanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TbSatuanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TbSatuan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TbSatuanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TbSatuanAggregateArgs>(args: Subset<T, TbSatuanAggregateArgs>): Prisma.PrismaPromise<GetTbSatuanAggregateType<T>>

    /**
     * Group by TbSatuan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbSatuanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tbSatuanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tbSatuanGroupByArgs['orderBy'] }
        : { orderBy?: tbSatuanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tbSatuanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTbSatuanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tbSatuan model
   */
  readonly fields: tbSatuanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tbSatuan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tbSatuanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tbSatuan model
   */ 
  interface tbSatuanFieldRefs {
    readonly kode_satuan: FieldRef<"tbSatuan", 'String'>
    readonly nama: FieldRef<"tbSatuan", 'String'>
    readonly aktif: FieldRef<"tbSatuan", 'StatusAktif'>
  }
    

  // Custom InputTypes
  /**
   * tbSatuan findUnique
   */
  export type tbSatuanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbSatuan
     */
    select?: tbSatuanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbSatuan
     */
    omit?: tbSatuanOmit<ExtArgs> | null
    /**
     * Filter, which tbSatuan to fetch.
     */
    where: tbSatuanWhereUniqueInput
  }

  /**
   * tbSatuan findUniqueOrThrow
   */
  export type tbSatuanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbSatuan
     */
    select?: tbSatuanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbSatuan
     */
    omit?: tbSatuanOmit<ExtArgs> | null
    /**
     * Filter, which tbSatuan to fetch.
     */
    where: tbSatuanWhereUniqueInput
  }

  /**
   * tbSatuan findFirst
   */
  export type tbSatuanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbSatuan
     */
    select?: tbSatuanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbSatuan
     */
    omit?: tbSatuanOmit<ExtArgs> | null
    /**
     * Filter, which tbSatuan to fetch.
     */
    where?: tbSatuanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbSatuans to fetch.
     */
    orderBy?: tbSatuanOrderByWithRelationInput | tbSatuanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbSatuans.
     */
    cursor?: tbSatuanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbSatuans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbSatuans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbSatuans.
     */
    distinct?: TbSatuanScalarFieldEnum | TbSatuanScalarFieldEnum[]
  }

  /**
   * tbSatuan findFirstOrThrow
   */
  export type tbSatuanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbSatuan
     */
    select?: tbSatuanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbSatuan
     */
    omit?: tbSatuanOmit<ExtArgs> | null
    /**
     * Filter, which tbSatuan to fetch.
     */
    where?: tbSatuanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbSatuans to fetch.
     */
    orderBy?: tbSatuanOrderByWithRelationInput | tbSatuanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbSatuans.
     */
    cursor?: tbSatuanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbSatuans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbSatuans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbSatuans.
     */
    distinct?: TbSatuanScalarFieldEnum | TbSatuanScalarFieldEnum[]
  }

  /**
   * tbSatuan findMany
   */
  export type tbSatuanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbSatuan
     */
    select?: tbSatuanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbSatuan
     */
    omit?: tbSatuanOmit<ExtArgs> | null
    /**
     * Filter, which tbSatuans to fetch.
     */
    where?: tbSatuanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbSatuans to fetch.
     */
    orderBy?: tbSatuanOrderByWithRelationInput | tbSatuanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tbSatuans.
     */
    cursor?: tbSatuanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbSatuans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbSatuans.
     */
    skip?: number
    distinct?: TbSatuanScalarFieldEnum | TbSatuanScalarFieldEnum[]
  }

  /**
   * tbSatuan create
   */
  export type tbSatuanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbSatuan
     */
    select?: tbSatuanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbSatuan
     */
    omit?: tbSatuanOmit<ExtArgs> | null
    /**
     * The data needed to create a tbSatuan.
     */
    data: XOR<tbSatuanCreateInput, tbSatuanUncheckedCreateInput>
  }

  /**
   * tbSatuan createMany
   */
  export type tbSatuanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tbSatuans.
     */
    data: tbSatuanCreateManyInput | tbSatuanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tbSatuan update
   */
  export type tbSatuanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbSatuan
     */
    select?: tbSatuanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbSatuan
     */
    omit?: tbSatuanOmit<ExtArgs> | null
    /**
     * The data needed to update a tbSatuan.
     */
    data: XOR<tbSatuanUpdateInput, tbSatuanUncheckedUpdateInput>
    /**
     * Choose, which tbSatuan to update.
     */
    where: tbSatuanWhereUniqueInput
  }

  /**
   * tbSatuan updateMany
   */
  export type tbSatuanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tbSatuans.
     */
    data: XOR<tbSatuanUpdateManyMutationInput, tbSatuanUncheckedUpdateManyInput>
    /**
     * Filter which tbSatuans to update
     */
    where?: tbSatuanWhereInput
    /**
     * Limit how many tbSatuans to update.
     */
    limit?: number
  }

  /**
   * tbSatuan upsert
   */
  export type tbSatuanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbSatuan
     */
    select?: tbSatuanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbSatuan
     */
    omit?: tbSatuanOmit<ExtArgs> | null
    /**
     * The filter to search for the tbSatuan to update in case it exists.
     */
    where: tbSatuanWhereUniqueInput
    /**
     * In case the tbSatuan found by the `where` argument doesn't exist, create a new tbSatuan with this data.
     */
    create: XOR<tbSatuanCreateInput, tbSatuanUncheckedCreateInput>
    /**
     * In case the tbSatuan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tbSatuanUpdateInput, tbSatuanUncheckedUpdateInput>
  }

  /**
   * tbSatuan delete
   */
  export type tbSatuanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbSatuan
     */
    select?: tbSatuanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbSatuan
     */
    omit?: tbSatuanOmit<ExtArgs> | null
    /**
     * Filter which tbSatuan to delete.
     */
    where: tbSatuanWhereUniqueInput
  }

  /**
   * tbSatuan deleteMany
   */
  export type tbSatuanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tbSatuans to delete
     */
    where?: tbSatuanWhereInput
    /**
     * Limit how many tbSatuans to delete.
     */
    limit?: number
  }

  /**
   * tbSatuan without action
   */
  export type tbSatuanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbSatuan
     */
    select?: tbSatuanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbSatuan
     */
    omit?: tbSatuanOmit<ExtArgs> | null
  }


  /**
   * Model tbAnggota
   */

  export type AggregateTbAnggota = {
    _count: TbAnggotaCountAggregateOutputType | null
    _avg: TbAnggotaAvgAggregateOutputType | null
    _sum: TbAnggotaSumAggregateOutputType | null
    _min: TbAnggotaMinAggregateOutputType | null
    _max: TbAnggotaMaxAggregateOutputType | null
  }

  export type TbAnggotaAvgAggregateOutputType = {
    Limit_Piutang: number | null
  }

  export type TbAnggotaSumAggregateOutputType = {
    Limit_Piutang: number | null
  }

  export type TbAnggotaMinAggregateOutputType = {
    NIP: string | null
    Nama_Anggota: string | null
    Nomor_rekening: string | null
    bank: string | null
    no_hp: string | null
    Alamat: string | null
    Limit_Piutang: number | null
    aktif: $Enums.StatusAktif | null
  }

  export type TbAnggotaMaxAggregateOutputType = {
    NIP: string | null
    Nama_Anggota: string | null
    Nomor_rekening: string | null
    bank: string | null
    no_hp: string | null
    Alamat: string | null
    Limit_Piutang: number | null
    aktif: $Enums.StatusAktif | null
  }

  export type TbAnggotaCountAggregateOutputType = {
    NIP: number
    Nama_Anggota: number
    Nomor_rekening: number
    bank: number
    no_hp: number
    Alamat: number
    Limit_Piutang: number
    aktif: number
    _all: number
  }


  export type TbAnggotaAvgAggregateInputType = {
    Limit_Piutang?: true
  }

  export type TbAnggotaSumAggregateInputType = {
    Limit_Piutang?: true
  }

  export type TbAnggotaMinAggregateInputType = {
    NIP?: true
    Nama_Anggota?: true
    Nomor_rekening?: true
    bank?: true
    no_hp?: true
    Alamat?: true
    Limit_Piutang?: true
    aktif?: true
  }

  export type TbAnggotaMaxAggregateInputType = {
    NIP?: true
    Nama_Anggota?: true
    Nomor_rekening?: true
    bank?: true
    no_hp?: true
    Alamat?: true
    Limit_Piutang?: true
    aktif?: true
  }

  export type TbAnggotaCountAggregateInputType = {
    NIP?: true
    Nama_Anggota?: true
    Nomor_rekening?: true
    bank?: true
    no_hp?: true
    Alamat?: true
    Limit_Piutang?: true
    aktif?: true
    _all?: true
  }

  export type TbAnggotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tbAnggota to aggregate.
     */
    where?: tbAnggotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbAnggotas to fetch.
     */
    orderBy?: tbAnggotaOrderByWithRelationInput | tbAnggotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tbAnggotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbAnggotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbAnggotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tbAnggotas
    **/
    _count?: true | TbAnggotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TbAnggotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TbAnggotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TbAnggotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TbAnggotaMaxAggregateInputType
  }

  export type GetTbAnggotaAggregateType<T extends TbAnggotaAggregateArgs> = {
        [P in keyof T & keyof AggregateTbAnggota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTbAnggota[P]>
      : GetScalarType<T[P], AggregateTbAnggota[P]>
  }




  export type tbAnggotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tbAnggotaWhereInput
    orderBy?: tbAnggotaOrderByWithAggregationInput | tbAnggotaOrderByWithAggregationInput[]
    by: TbAnggotaScalarFieldEnum[] | TbAnggotaScalarFieldEnum
    having?: tbAnggotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TbAnggotaCountAggregateInputType | true
    _avg?: TbAnggotaAvgAggregateInputType
    _sum?: TbAnggotaSumAggregateInputType
    _min?: TbAnggotaMinAggregateInputType
    _max?: TbAnggotaMaxAggregateInputType
  }

  export type TbAnggotaGroupByOutputType = {
    NIP: string
    Nama_Anggota: string | null
    Nomor_rekening: string
    bank: string
    no_hp: string
    Alamat: string
    Limit_Piutang: number
    aktif: $Enums.StatusAktif
    _count: TbAnggotaCountAggregateOutputType | null
    _avg: TbAnggotaAvgAggregateOutputType | null
    _sum: TbAnggotaSumAggregateOutputType | null
    _min: TbAnggotaMinAggregateOutputType | null
    _max: TbAnggotaMaxAggregateOutputType | null
  }

  type GetTbAnggotaGroupByPayload<T extends tbAnggotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TbAnggotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TbAnggotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TbAnggotaGroupByOutputType[P]>
            : GetScalarType<T[P], TbAnggotaGroupByOutputType[P]>
        }
      >
    >


  export type tbAnggotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    NIP?: boolean
    Nama_Anggota?: boolean
    Nomor_rekening?: boolean
    bank?: boolean
    no_hp?: boolean
    Alamat?: boolean
    Limit_Piutang?: boolean
    aktif?: boolean
  }, ExtArgs["result"]["tbAnggota"]>



  export type tbAnggotaSelectScalar = {
    NIP?: boolean
    Nama_Anggota?: boolean
    Nomor_rekening?: boolean
    bank?: boolean
    no_hp?: boolean
    Alamat?: boolean
    Limit_Piutang?: boolean
    aktif?: boolean
  }

  export type tbAnggotaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"NIP" | "Nama_Anggota" | "Nomor_rekening" | "bank" | "no_hp" | "Alamat" | "Limit_Piutang" | "aktif", ExtArgs["result"]["tbAnggota"]>

  export type $tbAnggotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tbAnggota"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      NIP: string
      Nama_Anggota: string | null
      Nomor_rekening: string
      bank: string
      no_hp: string
      Alamat: string
      Limit_Piutang: number
      aktif: $Enums.StatusAktif
    }, ExtArgs["result"]["tbAnggota"]>
    composites: {}
  }

  type tbAnggotaGetPayload<S extends boolean | null | undefined | tbAnggotaDefaultArgs> = $Result.GetResult<Prisma.$tbAnggotaPayload, S>

  type tbAnggotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tbAnggotaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TbAnggotaCountAggregateInputType | true
    }

  export interface tbAnggotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tbAnggota'], meta: { name: 'tbAnggota' } }
    /**
     * Find zero or one TbAnggota that matches the filter.
     * @param {tbAnggotaFindUniqueArgs} args - Arguments to find a TbAnggota
     * @example
     * // Get one TbAnggota
     * const tbAnggota = await prisma.tbAnggota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tbAnggotaFindUniqueArgs>(args: SelectSubset<T, tbAnggotaFindUniqueArgs<ExtArgs>>): Prisma__tbAnggotaClient<$Result.GetResult<Prisma.$tbAnggotaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TbAnggota that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tbAnggotaFindUniqueOrThrowArgs} args - Arguments to find a TbAnggota
     * @example
     * // Get one TbAnggota
     * const tbAnggota = await prisma.tbAnggota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tbAnggotaFindUniqueOrThrowArgs>(args: SelectSubset<T, tbAnggotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tbAnggotaClient<$Result.GetResult<Prisma.$tbAnggotaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TbAnggota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbAnggotaFindFirstArgs} args - Arguments to find a TbAnggota
     * @example
     * // Get one TbAnggota
     * const tbAnggota = await prisma.tbAnggota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tbAnggotaFindFirstArgs>(args?: SelectSubset<T, tbAnggotaFindFirstArgs<ExtArgs>>): Prisma__tbAnggotaClient<$Result.GetResult<Prisma.$tbAnggotaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TbAnggota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbAnggotaFindFirstOrThrowArgs} args - Arguments to find a TbAnggota
     * @example
     * // Get one TbAnggota
     * const tbAnggota = await prisma.tbAnggota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tbAnggotaFindFirstOrThrowArgs>(args?: SelectSubset<T, tbAnggotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__tbAnggotaClient<$Result.GetResult<Prisma.$tbAnggotaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TbAnggotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbAnggotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TbAnggotas
     * const tbAnggotas = await prisma.tbAnggota.findMany()
     * 
     * // Get first 10 TbAnggotas
     * const tbAnggotas = await prisma.tbAnggota.findMany({ take: 10 })
     * 
     * // Only select the `NIP`
     * const tbAnggotaWithNIPOnly = await prisma.tbAnggota.findMany({ select: { NIP: true } })
     * 
     */
    findMany<T extends tbAnggotaFindManyArgs>(args?: SelectSubset<T, tbAnggotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tbAnggotaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TbAnggota.
     * @param {tbAnggotaCreateArgs} args - Arguments to create a TbAnggota.
     * @example
     * // Create one TbAnggota
     * const TbAnggota = await prisma.tbAnggota.create({
     *   data: {
     *     // ... data to create a TbAnggota
     *   }
     * })
     * 
     */
    create<T extends tbAnggotaCreateArgs>(args: SelectSubset<T, tbAnggotaCreateArgs<ExtArgs>>): Prisma__tbAnggotaClient<$Result.GetResult<Prisma.$tbAnggotaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TbAnggotas.
     * @param {tbAnggotaCreateManyArgs} args - Arguments to create many TbAnggotas.
     * @example
     * // Create many TbAnggotas
     * const tbAnggota = await prisma.tbAnggota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tbAnggotaCreateManyArgs>(args?: SelectSubset<T, tbAnggotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TbAnggota.
     * @param {tbAnggotaDeleteArgs} args - Arguments to delete one TbAnggota.
     * @example
     * // Delete one TbAnggota
     * const TbAnggota = await prisma.tbAnggota.delete({
     *   where: {
     *     // ... filter to delete one TbAnggota
     *   }
     * })
     * 
     */
    delete<T extends tbAnggotaDeleteArgs>(args: SelectSubset<T, tbAnggotaDeleteArgs<ExtArgs>>): Prisma__tbAnggotaClient<$Result.GetResult<Prisma.$tbAnggotaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TbAnggota.
     * @param {tbAnggotaUpdateArgs} args - Arguments to update one TbAnggota.
     * @example
     * // Update one TbAnggota
     * const tbAnggota = await prisma.tbAnggota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tbAnggotaUpdateArgs>(args: SelectSubset<T, tbAnggotaUpdateArgs<ExtArgs>>): Prisma__tbAnggotaClient<$Result.GetResult<Prisma.$tbAnggotaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TbAnggotas.
     * @param {tbAnggotaDeleteManyArgs} args - Arguments to filter TbAnggotas to delete.
     * @example
     * // Delete a few TbAnggotas
     * const { count } = await prisma.tbAnggota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tbAnggotaDeleteManyArgs>(args?: SelectSubset<T, tbAnggotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TbAnggotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbAnggotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TbAnggotas
     * const tbAnggota = await prisma.tbAnggota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tbAnggotaUpdateManyArgs>(args: SelectSubset<T, tbAnggotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TbAnggota.
     * @param {tbAnggotaUpsertArgs} args - Arguments to update or create a TbAnggota.
     * @example
     * // Update or create a TbAnggota
     * const tbAnggota = await prisma.tbAnggota.upsert({
     *   create: {
     *     // ... data to create a TbAnggota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TbAnggota we want to update
     *   }
     * })
     */
    upsert<T extends tbAnggotaUpsertArgs>(args: SelectSubset<T, tbAnggotaUpsertArgs<ExtArgs>>): Prisma__tbAnggotaClient<$Result.GetResult<Prisma.$tbAnggotaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TbAnggotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbAnggotaCountArgs} args - Arguments to filter TbAnggotas to count.
     * @example
     * // Count the number of TbAnggotas
     * const count = await prisma.tbAnggota.count({
     *   where: {
     *     // ... the filter for the TbAnggotas we want to count
     *   }
     * })
    **/
    count<T extends tbAnggotaCountArgs>(
      args?: Subset<T, tbAnggotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TbAnggotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TbAnggota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TbAnggotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TbAnggotaAggregateArgs>(args: Subset<T, TbAnggotaAggregateArgs>): Prisma.PrismaPromise<GetTbAnggotaAggregateType<T>>

    /**
     * Group by TbAnggota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbAnggotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tbAnggotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tbAnggotaGroupByArgs['orderBy'] }
        : { orderBy?: tbAnggotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tbAnggotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTbAnggotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tbAnggota model
   */
  readonly fields: tbAnggotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tbAnggota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tbAnggotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tbAnggota model
   */ 
  interface tbAnggotaFieldRefs {
    readonly NIP: FieldRef<"tbAnggota", 'String'>
    readonly Nama_Anggota: FieldRef<"tbAnggota", 'String'>
    readonly Nomor_rekening: FieldRef<"tbAnggota", 'String'>
    readonly bank: FieldRef<"tbAnggota", 'String'>
    readonly no_hp: FieldRef<"tbAnggota", 'String'>
    readonly Alamat: FieldRef<"tbAnggota", 'String'>
    readonly Limit_Piutang: FieldRef<"tbAnggota", 'Int'>
    readonly aktif: FieldRef<"tbAnggota", 'StatusAktif'>
  }
    

  // Custom InputTypes
  /**
   * tbAnggota findUnique
   */
  export type tbAnggotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbAnggota
     */
    select?: tbAnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbAnggota
     */
    omit?: tbAnggotaOmit<ExtArgs> | null
    /**
     * Filter, which tbAnggota to fetch.
     */
    where: tbAnggotaWhereUniqueInput
  }

  /**
   * tbAnggota findUniqueOrThrow
   */
  export type tbAnggotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbAnggota
     */
    select?: tbAnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbAnggota
     */
    omit?: tbAnggotaOmit<ExtArgs> | null
    /**
     * Filter, which tbAnggota to fetch.
     */
    where: tbAnggotaWhereUniqueInput
  }

  /**
   * tbAnggota findFirst
   */
  export type tbAnggotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbAnggota
     */
    select?: tbAnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbAnggota
     */
    omit?: tbAnggotaOmit<ExtArgs> | null
    /**
     * Filter, which tbAnggota to fetch.
     */
    where?: tbAnggotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbAnggotas to fetch.
     */
    orderBy?: tbAnggotaOrderByWithRelationInput | tbAnggotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbAnggotas.
     */
    cursor?: tbAnggotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbAnggotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbAnggotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbAnggotas.
     */
    distinct?: TbAnggotaScalarFieldEnum | TbAnggotaScalarFieldEnum[]
  }

  /**
   * tbAnggota findFirstOrThrow
   */
  export type tbAnggotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbAnggota
     */
    select?: tbAnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbAnggota
     */
    omit?: tbAnggotaOmit<ExtArgs> | null
    /**
     * Filter, which tbAnggota to fetch.
     */
    where?: tbAnggotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbAnggotas to fetch.
     */
    orderBy?: tbAnggotaOrderByWithRelationInput | tbAnggotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbAnggotas.
     */
    cursor?: tbAnggotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbAnggotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbAnggotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbAnggotas.
     */
    distinct?: TbAnggotaScalarFieldEnum | TbAnggotaScalarFieldEnum[]
  }

  /**
   * tbAnggota findMany
   */
  export type tbAnggotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbAnggota
     */
    select?: tbAnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbAnggota
     */
    omit?: tbAnggotaOmit<ExtArgs> | null
    /**
     * Filter, which tbAnggotas to fetch.
     */
    where?: tbAnggotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbAnggotas to fetch.
     */
    orderBy?: tbAnggotaOrderByWithRelationInput | tbAnggotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tbAnggotas.
     */
    cursor?: tbAnggotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbAnggotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbAnggotas.
     */
    skip?: number
    distinct?: TbAnggotaScalarFieldEnum | TbAnggotaScalarFieldEnum[]
  }

  /**
   * tbAnggota create
   */
  export type tbAnggotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbAnggota
     */
    select?: tbAnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbAnggota
     */
    omit?: tbAnggotaOmit<ExtArgs> | null
    /**
     * The data needed to create a tbAnggota.
     */
    data: XOR<tbAnggotaCreateInput, tbAnggotaUncheckedCreateInput>
  }

  /**
   * tbAnggota createMany
   */
  export type tbAnggotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tbAnggotas.
     */
    data: tbAnggotaCreateManyInput | tbAnggotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tbAnggota update
   */
  export type tbAnggotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbAnggota
     */
    select?: tbAnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbAnggota
     */
    omit?: tbAnggotaOmit<ExtArgs> | null
    /**
     * The data needed to update a tbAnggota.
     */
    data: XOR<tbAnggotaUpdateInput, tbAnggotaUncheckedUpdateInput>
    /**
     * Choose, which tbAnggota to update.
     */
    where: tbAnggotaWhereUniqueInput
  }

  /**
   * tbAnggota updateMany
   */
  export type tbAnggotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tbAnggotas.
     */
    data: XOR<tbAnggotaUpdateManyMutationInput, tbAnggotaUncheckedUpdateManyInput>
    /**
     * Filter which tbAnggotas to update
     */
    where?: tbAnggotaWhereInput
    /**
     * Limit how many tbAnggotas to update.
     */
    limit?: number
  }

  /**
   * tbAnggota upsert
   */
  export type tbAnggotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbAnggota
     */
    select?: tbAnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbAnggota
     */
    omit?: tbAnggotaOmit<ExtArgs> | null
    /**
     * The filter to search for the tbAnggota to update in case it exists.
     */
    where: tbAnggotaWhereUniqueInput
    /**
     * In case the tbAnggota found by the `where` argument doesn't exist, create a new tbAnggota with this data.
     */
    create: XOR<tbAnggotaCreateInput, tbAnggotaUncheckedCreateInput>
    /**
     * In case the tbAnggota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tbAnggotaUpdateInput, tbAnggotaUncheckedUpdateInput>
  }

  /**
   * tbAnggota delete
   */
  export type tbAnggotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbAnggota
     */
    select?: tbAnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbAnggota
     */
    omit?: tbAnggotaOmit<ExtArgs> | null
    /**
     * Filter which tbAnggota to delete.
     */
    where: tbAnggotaWhereUniqueInput
  }

  /**
   * tbAnggota deleteMany
   */
  export type tbAnggotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tbAnggotas to delete
     */
    where?: tbAnggotaWhereInput
    /**
     * Limit how many tbAnggotas to delete.
     */
    limit?: number
  }

  /**
   * tbAnggota without action
   */
  export type tbAnggotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbAnggota
     */
    select?: tbAnggotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbAnggota
     */
    omit?: tbAnggotaOmit<ExtArgs> | null
  }


  /**
   * Model tbDetail_Pengurus
   */

  export type AggregateTbDetail_Pengurus = {
    _count: TbDetail_PengurusCountAggregateOutputType | null
    _avg: TbDetail_PengurusAvgAggregateOutputType | null
    _sum: TbDetail_PengurusSumAggregateOutputType | null
    _min: TbDetail_PengurusMinAggregateOutputType | null
    _max: TbDetail_PengurusMaxAggregateOutputType | null
  }

  export type TbDetail_PengurusAvgAggregateOutputType = {
    tahun: number | null
    tunjangan: Decimal | null
  }

  export type TbDetail_PengurusSumAggregateOutputType = {
    tahun: number | null
    tunjangan: Decimal | null
  }

  export type TbDetail_PengurusMinAggregateOutputType = {
    kode_detail: string | null
    tahun: number | null
    nip: string | null
    kode_pengurus: string | null
    tgl_menjabat: Date | null
    tgl_akhirmenjabat: Date | null
    tunjangan: Decimal | null
    aktif: $Enums.StatusAktif | null
  }

  export type TbDetail_PengurusMaxAggregateOutputType = {
    kode_detail: string | null
    tahun: number | null
    nip: string | null
    kode_pengurus: string | null
    tgl_menjabat: Date | null
    tgl_akhirmenjabat: Date | null
    tunjangan: Decimal | null
    aktif: $Enums.StatusAktif | null
  }

  export type TbDetail_PengurusCountAggregateOutputType = {
    kode_detail: number
    tahun: number
    nip: number
    kode_pengurus: number
    tgl_menjabat: number
    tgl_akhirmenjabat: number
    tunjangan: number
    aktif: number
    _all: number
  }


  export type TbDetail_PengurusAvgAggregateInputType = {
    tahun?: true
    tunjangan?: true
  }

  export type TbDetail_PengurusSumAggregateInputType = {
    tahun?: true
    tunjangan?: true
  }

  export type TbDetail_PengurusMinAggregateInputType = {
    kode_detail?: true
    tahun?: true
    nip?: true
    kode_pengurus?: true
    tgl_menjabat?: true
    tgl_akhirmenjabat?: true
    tunjangan?: true
    aktif?: true
  }

  export type TbDetail_PengurusMaxAggregateInputType = {
    kode_detail?: true
    tahun?: true
    nip?: true
    kode_pengurus?: true
    tgl_menjabat?: true
    tgl_akhirmenjabat?: true
    tunjangan?: true
    aktif?: true
  }

  export type TbDetail_PengurusCountAggregateInputType = {
    kode_detail?: true
    tahun?: true
    nip?: true
    kode_pengurus?: true
    tgl_menjabat?: true
    tgl_akhirmenjabat?: true
    tunjangan?: true
    aktif?: true
    _all?: true
  }

  export type TbDetail_PengurusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tbDetail_Pengurus to aggregate.
     */
    where?: tbDetail_PengurusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbDetail_Penguruses to fetch.
     */
    orderBy?: tbDetail_PengurusOrderByWithRelationInput | tbDetail_PengurusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tbDetail_PengurusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbDetail_Penguruses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbDetail_Penguruses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tbDetail_Penguruses
    **/
    _count?: true | TbDetail_PengurusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TbDetail_PengurusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TbDetail_PengurusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TbDetail_PengurusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TbDetail_PengurusMaxAggregateInputType
  }

  export type GetTbDetail_PengurusAggregateType<T extends TbDetail_PengurusAggregateArgs> = {
        [P in keyof T & keyof AggregateTbDetail_Pengurus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTbDetail_Pengurus[P]>
      : GetScalarType<T[P], AggregateTbDetail_Pengurus[P]>
  }




  export type tbDetail_PengurusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tbDetail_PengurusWhereInput
    orderBy?: tbDetail_PengurusOrderByWithAggregationInput | tbDetail_PengurusOrderByWithAggregationInput[]
    by: TbDetail_PengurusScalarFieldEnum[] | TbDetail_PengurusScalarFieldEnum
    having?: tbDetail_PengurusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TbDetail_PengurusCountAggregateInputType | true
    _avg?: TbDetail_PengurusAvgAggregateInputType
    _sum?: TbDetail_PengurusSumAggregateInputType
    _min?: TbDetail_PengurusMinAggregateInputType
    _max?: TbDetail_PengurusMaxAggregateInputType
  }

  export type TbDetail_PengurusGroupByOutputType = {
    kode_detail: string
    tahun: number
    nip: string
    kode_pengurus: string
    tgl_menjabat: Date
    tgl_akhirmenjabat: Date
    tunjangan: Decimal | null
    aktif: $Enums.StatusAktif
    _count: TbDetail_PengurusCountAggregateOutputType | null
    _avg: TbDetail_PengurusAvgAggregateOutputType | null
    _sum: TbDetail_PengurusSumAggregateOutputType | null
    _min: TbDetail_PengurusMinAggregateOutputType | null
    _max: TbDetail_PengurusMaxAggregateOutputType | null
  }

  type GetTbDetail_PengurusGroupByPayload<T extends tbDetail_PengurusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TbDetail_PengurusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TbDetail_PengurusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TbDetail_PengurusGroupByOutputType[P]>
            : GetScalarType<T[P], TbDetail_PengurusGroupByOutputType[P]>
        }
      >
    >


  export type tbDetail_PengurusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    kode_detail?: boolean
    tahun?: boolean
    nip?: boolean
    kode_pengurus?: boolean
    tgl_menjabat?: boolean
    tgl_akhirmenjabat?: boolean
    tunjangan?: boolean
    aktif?: boolean
    pengurus?: boolean | tbPengurusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tbDetail_Pengurus"]>



  export type tbDetail_PengurusSelectScalar = {
    kode_detail?: boolean
    tahun?: boolean
    nip?: boolean
    kode_pengurus?: boolean
    tgl_menjabat?: boolean
    tgl_akhirmenjabat?: boolean
    tunjangan?: boolean
    aktif?: boolean
  }

  export type tbDetail_PengurusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"kode_detail" | "tahun" | "nip" | "kode_pengurus" | "tgl_menjabat" | "tgl_akhirmenjabat" | "tunjangan" | "aktif", ExtArgs["result"]["tbDetail_Pengurus"]>
  export type tbDetail_PengurusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pengurus?: boolean | tbPengurusDefaultArgs<ExtArgs>
  }

  export type $tbDetail_PengurusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tbDetail_Pengurus"
    objects: {
      pengurus: Prisma.$tbPengurusPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      kode_detail: string
      tahun: number
      nip: string
      kode_pengurus: string
      tgl_menjabat: Date
      tgl_akhirmenjabat: Date
      tunjangan: Prisma.Decimal | null
      aktif: $Enums.StatusAktif
    }, ExtArgs["result"]["tbDetail_Pengurus"]>
    composites: {}
  }

  type tbDetail_PengurusGetPayload<S extends boolean | null | undefined | tbDetail_PengurusDefaultArgs> = $Result.GetResult<Prisma.$tbDetail_PengurusPayload, S>

  type tbDetail_PengurusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tbDetail_PengurusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TbDetail_PengurusCountAggregateInputType | true
    }

  export interface tbDetail_PengurusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tbDetail_Pengurus'], meta: { name: 'tbDetail_Pengurus' } }
    /**
     * Find zero or one TbDetail_Pengurus that matches the filter.
     * @param {tbDetail_PengurusFindUniqueArgs} args - Arguments to find a TbDetail_Pengurus
     * @example
     * // Get one TbDetail_Pengurus
     * const tbDetail_Pengurus = await prisma.tbDetail_Pengurus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tbDetail_PengurusFindUniqueArgs>(args: SelectSubset<T, tbDetail_PengurusFindUniqueArgs<ExtArgs>>): Prisma__tbDetail_PengurusClient<$Result.GetResult<Prisma.$tbDetail_PengurusPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TbDetail_Pengurus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tbDetail_PengurusFindUniqueOrThrowArgs} args - Arguments to find a TbDetail_Pengurus
     * @example
     * // Get one TbDetail_Pengurus
     * const tbDetail_Pengurus = await prisma.tbDetail_Pengurus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tbDetail_PengurusFindUniqueOrThrowArgs>(args: SelectSubset<T, tbDetail_PengurusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tbDetail_PengurusClient<$Result.GetResult<Prisma.$tbDetail_PengurusPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TbDetail_Pengurus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbDetail_PengurusFindFirstArgs} args - Arguments to find a TbDetail_Pengurus
     * @example
     * // Get one TbDetail_Pengurus
     * const tbDetail_Pengurus = await prisma.tbDetail_Pengurus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tbDetail_PengurusFindFirstArgs>(args?: SelectSubset<T, tbDetail_PengurusFindFirstArgs<ExtArgs>>): Prisma__tbDetail_PengurusClient<$Result.GetResult<Prisma.$tbDetail_PengurusPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TbDetail_Pengurus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbDetail_PengurusFindFirstOrThrowArgs} args - Arguments to find a TbDetail_Pengurus
     * @example
     * // Get one TbDetail_Pengurus
     * const tbDetail_Pengurus = await prisma.tbDetail_Pengurus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tbDetail_PengurusFindFirstOrThrowArgs>(args?: SelectSubset<T, tbDetail_PengurusFindFirstOrThrowArgs<ExtArgs>>): Prisma__tbDetail_PengurusClient<$Result.GetResult<Prisma.$tbDetail_PengurusPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TbDetail_Penguruses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbDetail_PengurusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TbDetail_Penguruses
     * const tbDetail_Penguruses = await prisma.tbDetail_Pengurus.findMany()
     * 
     * // Get first 10 TbDetail_Penguruses
     * const tbDetail_Penguruses = await prisma.tbDetail_Pengurus.findMany({ take: 10 })
     * 
     * // Only select the `kode_detail`
     * const tbDetail_PengurusWithKode_detailOnly = await prisma.tbDetail_Pengurus.findMany({ select: { kode_detail: true } })
     * 
     */
    findMany<T extends tbDetail_PengurusFindManyArgs>(args?: SelectSubset<T, tbDetail_PengurusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tbDetail_PengurusPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TbDetail_Pengurus.
     * @param {tbDetail_PengurusCreateArgs} args - Arguments to create a TbDetail_Pengurus.
     * @example
     * // Create one TbDetail_Pengurus
     * const TbDetail_Pengurus = await prisma.tbDetail_Pengurus.create({
     *   data: {
     *     // ... data to create a TbDetail_Pengurus
     *   }
     * })
     * 
     */
    create<T extends tbDetail_PengurusCreateArgs>(args: SelectSubset<T, tbDetail_PengurusCreateArgs<ExtArgs>>): Prisma__tbDetail_PengurusClient<$Result.GetResult<Prisma.$tbDetail_PengurusPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TbDetail_Penguruses.
     * @param {tbDetail_PengurusCreateManyArgs} args - Arguments to create many TbDetail_Penguruses.
     * @example
     * // Create many TbDetail_Penguruses
     * const tbDetail_Pengurus = await prisma.tbDetail_Pengurus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tbDetail_PengurusCreateManyArgs>(args?: SelectSubset<T, tbDetail_PengurusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TbDetail_Pengurus.
     * @param {tbDetail_PengurusDeleteArgs} args - Arguments to delete one TbDetail_Pengurus.
     * @example
     * // Delete one TbDetail_Pengurus
     * const TbDetail_Pengurus = await prisma.tbDetail_Pengurus.delete({
     *   where: {
     *     // ... filter to delete one TbDetail_Pengurus
     *   }
     * })
     * 
     */
    delete<T extends tbDetail_PengurusDeleteArgs>(args: SelectSubset<T, tbDetail_PengurusDeleteArgs<ExtArgs>>): Prisma__tbDetail_PengurusClient<$Result.GetResult<Prisma.$tbDetail_PengurusPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TbDetail_Pengurus.
     * @param {tbDetail_PengurusUpdateArgs} args - Arguments to update one TbDetail_Pengurus.
     * @example
     * // Update one TbDetail_Pengurus
     * const tbDetail_Pengurus = await prisma.tbDetail_Pengurus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tbDetail_PengurusUpdateArgs>(args: SelectSubset<T, tbDetail_PengurusUpdateArgs<ExtArgs>>): Prisma__tbDetail_PengurusClient<$Result.GetResult<Prisma.$tbDetail_PengurusPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TbDetail_Penguruses.
     * @param {tbDetail_PengurusDeleteManyArgs} args - Arguments to filter TbDetail_Penguruses to delete.
     * @example
     * // Delete a few TbDetail_Penguruses
     * const { count } = await prisma.tbDetail_Pengurus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tbDetail_PengurusDeleteManyArgs>(args?: SelectSubset<T, tbDetail_PengurusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TbDetail_Penguruses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbDetail_PengurusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TbDetail_Penguruses
     * const tbDetail_Pengurus = await prisma.tbDetail_Pengurus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tbDetail_PengurusUpdateManyArgs>(args: SelectSubset<T, tbDetail_PengurusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TbDetail_Pengurus.
     * @param {tbDetail_PengurusUpsertArgs} args - Arguments to update or create a TbDetail_Pengurus.
     * @example
     * // Update or create a TbDetail_Pengurus
     * const tbDetail_Pengurus = await prisma.tbDetail_Pengurus.upsert({
     *   create: {
     *     // ... data to create a TbDetail_Pengurus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TbDetail_Pengurus we want to update
     *   }
     * })
     */
    upsert<T extends tbDetail_PengurusUpsertArgs>(args: SelectSubset<T, tbDetail_PengurusUpsertArgs<ExtArgs>>): Prisma__tbDetail_PengurusClient<$Result.GetResult<Prisma.$tbDetail_PengurusPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TbDetail_Penguruses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbDetail_PengurusCountArgs} args - Arguments to filter TbDetail_Penguruses to count.
     * @example
     * // Count the number of TbDetail_Penguruses
     * const count = await prisma.tbDetail_Pengurus.count({
     *   where: {
     *     // ... the filter for the TbDetail_Penguruses we want to count
     *   }
     * })
    **/
    count<T extends tbDetail_PengurusCountArgs>(
      args?: Subset<T, tbDetail_PengurusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TbDetail_PengurusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TbDetail_Pengurus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TbDetail_PengurusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TbDetail_PengurusAggregateArgs>(args: Subset<T, TbDetail_PengurusAggregateArgs>): Prisma.PrismaPromise<GetTbDetail_PengurusAggregateType<T>>

    /**
     * Group by TbDetail_Pengurus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbDetail_PengurusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tbDetail_PengurusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tbDetail_PengurusGroupByArgs['orderBy'] }
        : { orderBy?: tbDetail_PengurusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tbDetail_PengurusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTbDetail_PengurusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tbDetail_Pengurus model
   */
  readonly fields: tbDetail_PengurusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tbDetail_Pengurus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tbDetail_PengurusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pengurus<T extends tbPengurusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tbPengurusDefaultArgs<ExtArgs>>): Prisma__tbPengurusClient<$Result.GetResult<Prisma.$tbPengurusPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tbDetail_Pengurus model
   */ 
  interface tbDetail_PengurusFieldRefs {
    readonly kode_detail: FieldRef<"tbDetail_Pengurus", 'String'>
    readonly tahun: FieldRef<"tbDetail_Pengurus", 'Int'>
    readonly nip: FieldRef<"tbDetail_Pengurus", 'String'>
    readonly kode_pengurus: FieldRef<"tbDetail_Pengurus", 'String'>
    readonly tgl_menjabat: FieldRef<"tbDetail_Pengurus", 'DateTime'>
    readonly tgl_akhirmenjabat: FieldRef<"tbDetail_Pengurus", 'DateTime'>
    readonly tunjangan: FieldRef<"tbDetail_Pengurus", 'Decimal'>
    readonly aktif: FieldRef<"tbDetail_Pengurus", 'StatusAktif'>
  }
    

  // Custom InputTypes
  /**
   * tbDetail_Pengurus findUnique
   */
  export type tbDetail_PengurusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbDetail_Pengurus
     */
    select?: tbDetail_PengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbDetail_Pengurus
     */
    omit?: tbDetail_PengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbDetail_PengurusInclude<ExtArgs> | null
    /**
     * Filter, which tbDetail_Pengurus to fetch.
     */
    where: tbDetail_PengurusWhereUniqueInput
  }

  /**
   * tbDetail_Pengurus findUniqueOrThrow
   */
  export type tbDetail_PengurusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbDetail_Pengurus
     */
    select?: tbDetail_PengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbDetail_Pengurus
     */
    omit?: tbDetail_PengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbDetail_PengurusInclude<ExtArgs> | null
    /**
     * Filter, which tbDetail_Pengurus to fetch.
     */
    where: tbDetail_PengurusWhereUniqueInput
  }

  /**
   * tbDetail_Pengurus findFirst
   */
  export type tbDetail_PengurusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbDetail_Pengurus
     */
    select?: tbDetail_PengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbDetail_Pengurus
     */
    omit?: tbDetail_PengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbDetail_PengurusInclude<ExtArgs> | null
    /**
     * Filter, which tbDetail_Pengurus to fetch.
     */
    where?: tbDetail_PengurusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbDetail_Penguruses to fetch.
     */
    orderBy?: tbDetail_PengurusOrderByWithRelationInput | tbDetail_PengurusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbDetail_Penguruses.
     */
    cursor?: tbDetail_PengurusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbDetail_Penguruses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbDetail_Penguruses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbDetail_Penguruses.
     */
    distinct?: TbDetail_PengurusScalarFieldEnum | TbDetail_PengurusScalarFieldEnum[]
  }

  /**
   * tbDetail_Pengurus findFirstOrThrow
   */
  export type tbDetail_PengurusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbDetail_Pengurus
     */
    select?: tbDetail_PengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbDetail_Pengurus
     */
    omit?: tbDetail_PengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbDetail_PengurusInclude<ExtArgs> | null
    /**
     * Filter, which tbDetail_Pengurus to fetch.
     */
    where?: tbDetail_PengurusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbDetail_Penguruses to fetch.
     */
    orderBy?: tbDetail_PengurusOrderByWithRelationInput | tbDetail_PengurusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbDetail_Penguruses.
     */
    cursor?: tbDetail_PengurusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbDetail_Penguruses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbDetail_Penguruses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbDetail_Penguruses.
     */
    distinct?: TbDetail_PengurusScalarFieldEnum | TbDetail_PengurusScalarFieldEnum[]
  }

  /**
   * tbDetail_Pengurus findMany
   */
  export type tbDetail_PengurusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbDetail_Pengurus
     */
    select?: tbDetail_PengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbDetail_Pengurus
     */
    omit?: tbDetail_PengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbDetail_PengurusInclude<ExtArgs> | null
    /**
     * Filter, which tbDetail_Penguruses to fetch.
     */
    where?: tbDetail_PengurusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbDetail_Penguruses to fetch.
     */
    orderBy?: tbDetail_PengurusOrderByWithRelationInput | tbDetail_PengurusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tbDetail_Penguruses.
     */
    cursor?: tbDetail_PengurusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbDetail_Penguruses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbDetail_Penguruses.
     */
    skip?: number
    distinct?: TbDetail_PengurusScalarFieldEnum | TbDetail_PengurusScalarFieldEnum[]
  }

  /**
   * tbDetail_Pengurus create
   */
  export type tbDetail_PengurusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbDetail_Pengurus
     */
    select?: tbDetail_PengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbDetail_Pengurus
     */
    omit?: tbDetail_PengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbDetail_PengurusInclude<ExtArgs> | null
    /**
     * The data needed to create a tbDetail_Pengurus.
     */
    data: XOR<tbDetail_PengurusCreateInput, tbDetail_PengurusUncheckedCreateInput>
  }

  /**
   * tbDetail_Pengurus createMany
   */
  export type tbDetail_PengurusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tbDetail_Penguruses.
     */
    data: tbDetail_PengurusCreateManyInput | tbDetail_PengurusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tbDetail_Pengurus update
   */
  export type tbDetail_PengurusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbDetail_Pengurus
     */
    select?: tbDetail_PengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbDetail_Pengurus
     */
    omit?: tbDetail_PengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbDetail_PengurusInclude<ExtArgs> | null
    /**
     * The data needed to update a tbDetail_Pengurus.
     */
    data: XOR<tbDetail_PengurusUpdateInput, tbDetail_PengurusUncheckedUpdateInput>
    /**
     * Choose, which tbDetail_Pengurus to update.
     */
    where: tbDetail_PengurusWhereUniqueInput
  }

  /**
   * tbDetail_Pengurus updateMany
   */
  export type tbDetail_PengurusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tbDetail_Penguruses.
     */
    data: XOR<tbDetail_PengurusUpdateManyMutationInput, tbDetail_PengurusUncheckedUpdateManyInput>
    /**
     * Filter which tbDetail_Penguruses to update
     */
    where?: tbDetail_PengurusWhereInput
    /**
     * Limit how many tbDetail_Penguruses to update.
     */
    limit?: number
  }

  /**
   * tbDetail_Pengurus upsert
   */
  export type tbDetail_PengurusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbDetail_Pengurus
     */
    select?: tbDetail_PengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbDetail_Pengurus
     */
    omit?: tbDetail_PengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbDetail_PengurusInclude<ExtArgs> | null
    /**
     * The filter to search for the tbDetail_Pengurus to update in case it exists.
     */
    where: tbDetail_PengurusWhereUniqueInput
    /**
     * In case the tbDetail_Pengurus found by the `where` argument doesn't exist, create a new tbDetail_Pengurus with this data.
     */
    create: XOR<tbDetail_PengurusCreateInput, tbDetail_PengurusUncheckedCreateInput>
    /**
     * In case the tbDetail_Pengurus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tbDetail_PengurusUpdateInput, tbDetail_PengurusUncheckedUpdateInput>
  }

  /**
   * tbDetail_Pengurus delete
   */
  export type tbDetail_PengurusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbDetail_Pengurus
     */
    select?: tbDetail_PengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbDetail_Pengurus
     */
    omit?: tbDetail_PengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbDetail_PengurusInclude<ExtArgs> | null
    /**
     * Filter which tbDetail_Pengurus to delete.
     */
    where: tbDetail_PengurusWhereUniqueInput
  }

  /**
   * tbDetail_Pengurus deleteMany
   */
  export type tbDetail_PengurusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tbDetail_Penguruses to delete
     */
    where?: tbDetail_PengurusWhereInput
    /**
     * Limit how many tbDetail_Penguruses to delete.
     */
    limit?: number
  }

  /**
   * tbDetail_Pengurus without action
   */
  export type tbDetail_PengurusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbDetail_Pengurus
     */
    select?: tbDetail_PengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbDetail_Pengurus
     */
    omit?: tbDetail_PengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbDetail_PengurusInclude<ExtArgs> | null
  }


  /**
   * Model tbPengurus
   */

  export type AggregateTbPengurus = {
    _count: TbPengurusCountAggregateOutputType | null
    _min: TbPengurusMinAggregateOutputType | null
    _max: TbPengurusMaxAggregateOutputType | null
  }

  export type TbPengurusMinAggregateOutputType = {
    kode_pengurus: string | null
    nama: string | null
    aktif: $Enums.StatusAktif | null
  }

  export type TbPengurusMaxAggregateOutputType = {
    kode_pengurus: string | null
    nama: string | null
    aktif: $Enums.StatusAktif | null
  }

  export type TbPengurusCountAggregateOutputType = {
    kode_pengurus: number
    nama: number
    aktif: number
    _all: number
  }


  export type TbPengurusMinAggregateInputType = {
    kode_pengurus?: true
    nama?: true
    aktif?: true
  }

  export type TbPengurusMaxAggregateInputType = {
    kode_pengurus?: true
    nama?: true
    aktif?: true
  }

  export type TbPengurusCountAggregateInputType = {
    kode_pengurus?: true
    nama?: true
    aktif?: true
    _all?: true
  }

  export type TbPengurusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tbPengurus to aggregate.
     */
    where?: tbPengurusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbPenguruses to fetch.
     */
    orderBy?: tbPengurusOrderByWithRelationInput | tbPengurusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tbPengurusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbPenguruses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbPenguruses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tbPenguruses
    **/
    _count?: true | TbPengurusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TbPengurusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TbPengurusMaxAggregateInputType
  }

  export type GetTbPengurusAggregateType<T extends TbPengurusAggregateArgs> = {
        [P in keyof T & keyof AggregateTbPengurus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTbPengurus[P]>
      : GetScalarType<T[P], AggregateTbPengurus[P]>
  }




  export type tbPengurusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tbPengurusWhereInput
    orderBy?: tbPengurusOrderByWithAggregationInput | tbPengurusOrderByWithAggregationInput[]
    by: TbPengurusScalarFieldEnum[] | TbPengurusScalarFieldEnum
    having?: tbPengurusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TbPengurusCountAggregateInputType | true
    _min?: TbPengurusMinAggregateInputType
    _max?: TbPengurusMaxAggregateInputType
  }

  export type TbPengurusGroupByOutputType = {
    kode_pengurus: string
    nama: string
    aktif: $Enums.StatusAktif
    _count: TbPengurusCountAggregateOutputType | null
    _min: TbPengurusMinAggregateOutputType | null
    _max: TbPengurusMaxAggregateOutputType | null
  }

  type GetTbPengurusGroupByPayload<T extends tbPengurusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TbPengurusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TbPengurusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TbPengurusGroupByOutputType[P]>
            : GetScalarType<T[P], TbPengurusGroupByOutputType[P]>
        }
      >
    >


  export type tbPengurusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    kode_pengurus?: boolean
    nama?: boolean
    aktif?: boolean
    detail_pengurus?: boolean | tbPengurus$detail_pengurusArgs<ExtArgs>
    _count?: boolean | TbPengurusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tbPengurus"]>



  export type tbPengurusSelectScalar = {
    kode_pengurus?: boolean
    nama?: boolean
    aktif?: boolean
  }

  export type tbPengurusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"kode_pengurus" | "nama" | "aktif", ExtArgs["result"]["tbPengurus"]>
  export type tbPengurusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detail_pengurus?: boolean | tbPengurus$detail_pengurusArgs<ExtArgs>
    _count?: boolean | TbPengurusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $tbPengurusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tbPengurus"
    objects: {
      detail_pengurus: Prisma.$tbDetail_PengurusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      kode_pengurus: string
      nama: string
      aktif: $Enums.StatusAktif
    }, ExtArgs["result"]["tbPengurus"]>
    composites: {}
  }

  type tbPengurusGetPayload<S extends boolean | null | undefined | tbPengurusDefaultArgs> = $Result.GetResult<Prisma.$tbPengurusPayload, S>

  type tbPengurusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tbPengurusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TbPengurusCountAggregateInputType | true
    }

  export interface tbPengurusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tbPengurus'], meta: { name: 'tbPengurus' } }
    /**
     * Find zero or one TbPengurus that matches the filter.
     * @param {tbPengurusFindUniqueArgs} args - Arguments to find a TbPengurus
     * @example
     * // Get one TbPengurus
     * const tbPengurus = await prisma.tbPengurus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tbPengurusFindUniqueArgs>(args: SelectSubset<T, tbPengurusFindUniqueArgs<ExtArgs>>): Prisma__tbPengurusClient<$Result.GetResult<Prisma.$tbPengurusPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TbPengurus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tbPengurusFindUniqueOrThrowArgs} args - Arguments to find a TbPengurus
     * @example
     * // Get one TbPengurus
     * const tbPengurus = await prisma.tbPengurus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tbPengurusFindUniqueOrThrowArgs>(args: SelectSubset<T, tbPengurusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tbPengurusClient<$Result.GetResult<Prisma.$tbPengurusPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TbPengurus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbPengurusFindFirstArgs} args - Arguments to find a TbPengurus
     * @example
     * // Get one TbPengurus
     * const tbPengurus = await prisma.tbPengurus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tbPengurusFindFirstArgs>(args?: SelectSubset<T, tbPengurusFindFirstArgs<ExtArgs>>): Prisma__tbPengurusClient<$Result.GetResult<Prisma.$tbPengurusPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TbPengurus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbPengurusFindFirstOrThrowArgs} args - Arguments to find a TbPengurus
     * @example
     * // Get one TbPengurus
     * const tbPengurus = await prisma.tbPengurus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tbPengurusFindFirstOrThrowArgs>(args?: SelectSubset<T, tbPengurusFindFirstOrThrowArgs<ExtArgs>>): Prisma__tbPengurusClient<$Result.GetResult<Prisma.$tbPengurusPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TbPenguruses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbPengurusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TbPenguruses
     * const tbPenguruses = await prisma.tbPengurus.findMany()
     * 
     * // Get first 10 TbPenguruses
     * const tbPenguruses = await prisma.tbPengurus.findMany({ take: 10 })
     * 
     * // Only select the `kode_pengurus`
     * const tbPengurusWithKode_pengurusOnly = await prisma.tbPengurus.findMany({ select: { kode_pengurus: true } })
     * 
     */
    findMany<T extends tbPengurusFindManyArgs>(args?: SelectSubset<T, tbPengurusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tbPengurusPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TbPengurus.
     * @param {tbPengurusCreateArgs} args - Arguments to create a TbPengurus.
     * @example
     * // Create one TbPengurus
     * const TbPengurus = await prisma.tbPengurus.create({
     *   data: {
     *     // ... data to create a TbPengurus
     *   }
     * })
     * 
     */
    create<T extends tbPengurusCreateArgs>(args: SelectSubset<T, tbPengurusCreateArgs<ExtArgs>>): Prisma__tbPengurusClient<$Result.GetResult<Prisma.$tbPengurusPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TbPenguruses.
     * @param {tbPengurusCreateManyArgs} args - Arguments to create many TbPenguruses.
     * @example
     * // Create many TbPenguruses
     * const tbPengurus = await prisma.tbPengurus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tbPengurusCreateManyArgs>(args?: SelectSubset<T, tbPengurusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TbPengurus.
     * @param {tbPengurusDeleteArgs} args - Arguments to delete one TbPengurus.
     * @example
     * // Delete one TbPengurus
     * const TbPengurus = await prisma.tbPengurus.delete({
     *   where: {
     *     // ... filter to delete one TbPengurus
     *   }
     * })
     * 
     */
    delete<T extends tbPengurusDeleteArgs>(args: SelectSubset<T, tbPengurusDeleteArgs<ExtArgs>>): Prisma__tbPengurusClient<$Result.GetResult<Prisma.$tbPengurusPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TbPengurus.
     * @param {tbPengurusUpdateArgs} args - Arguments to update one TbPengurus.
     * @example
     * // Update one TbPengurus
     * const tbPengurus = await prisma.tbPengurus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tbPengurusUpdateArgs>(args: SelectSubset<T, tbPengurusUpdateArgs<ExtArgs>>): Prisma__tbPengurusClient<$Result.GetResult<Prisma.$tbPengurusPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TbPenguruses.
     * @param {tbPengurusDeleteManyArgs} args - Arguments to filter TbPenguruses to delete.
     * @example
     * // Delete a few TbPenguruses
     * const { count } = await prisma.tbPengurus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tbPengurusDeleteManyArgs>(args?: SelectSubset<T, tbPengurusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TbPenguruses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbPengurusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TbPenguruses
     * const tbPengurus = await prisma.tbPengurus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tbPengurusUpdateManyArgs>(args: SelectSubset<T, tbPengurusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TbPengurus.
     * @param {tbPengurusUpsertArgs} args - Arguments to update or create a TbPengurus.
     * @example
     * // Update or create a TbPengurus
     * const tbPengurus = await prisma.tbPengurus.upsert({
     *   create: {
     *     // ... data to create a TbPengurus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TbPengurus we want to update
     *   }
     * })
     */
    upsert<T extends tbPengurusUpsertArgs>(args: SelectSubset<T, tbPengurusUpsertArgs<ExtArgs>>): Prisma__tbPengurusClient<$Result.GetResult<Prisma.$tbPengurusPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TbPenguruses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbPengurusCountArgs} args - Arguments to filter TbPenguruses to count.
     * @example
     * // Count the number of TbPenguruses
     * const count = await prisma.tbPengurus.count({
     *   where: {
     *     // ... the filter for the TbPenguruses we want to count
     *   }
     * })
    **/
    count<T extends tbPengurusCountArgs>(
      args?: Subset<T, tbPengurusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TbPengurusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TbPengurus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TbPengurusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TbPengurusAggregateArgs>(args: Subset<T, TbPengurusAggregateArgs>): Prisma.PrismaPromise<GetTbPengurusAggregateType<T>>

    /**
     * Group by TbPengurus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbPengurusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tbPengurusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tbPengurusGroupByArgs['orderBy'] }
        : { orderBy?: tbPengurusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tbPengurusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTbPengurusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tbPengurus model
   */
  readonly fields: tbPengurusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tbPengurus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tbPengurusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    detail_pengurus<T extends tbPengurus$detail_pengurusArgs<ExtArgs> = {}>(args?: Subset<T, tbPengurus$detail_pengurusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tbDetail_PengurusPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tbPengurus model
   */ 
  interface tbPengurusFieldRefs {
    readonly kode_pengurus: FieldRef<"tbPengurus", 'String'>
    readonly nama: FieldRef<"tbPengurus", 'String'>
    readonly aktif: FieldRef<"tbPengurus", 'StatusAktif'>
  }
    

  // Custom InputTypes
  /**
   * tbPengurus findUnique
   */
  export type tbPengurusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbPengurus
     */
    select?: tbPengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbPengurus
     */
    omit?: tbPengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbPengurusInclude<ExtArgs> | null
    /**
     * Filter, which tbPengurus to fetch.
     */
    where: tbPengurusWhereUniqueInput
  }

  /**
   * tbPengurus findUniqueOrThrow
   */
  export type tbPengurusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbPengurus
     */
    select?: tbPengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbPengurus
     */
    omit?: tbPengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbPengurusInclude<ExtArgs> | null
    /**
     * Filter, which tbPengurus to fetch.
     */
    where: tbPengurusWhereUniqueInput
  }

  /**
   * tbPengurus findFirst
   */
  export type tbPengurusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbPengurus
     */
    select?: tbPengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbPengurus
     */
    omit?: tbPengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbPengurusInclude<ExtArgs> | null
    /**
     * Filter, which tbPengurus to fetch.
     */
    where?: tbPengurusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbPenguruses to fetch.
     */
    orderBy?: tbPengurusOrderByWithRelationInput | tbPengurusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbPenguruses.
     */
    cursor?: tbPengurusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbPenguruses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbPenguruses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbPenguruses.
     */
    distinct?: TbPengurusScalarFieldEnum | TbPengurusScalarFieldEnum[]
  }

  /**
   * tbPengurus findFirstOrThrow
   */
  export type tbPengurusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbPengurus
     */
    select?: tbPengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbPengurus
     */
    omit?: tbPengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbPengurusInclude<ExtArgs> | null
    /**
     * Filter, which tbPengurus to fetch.
     */
    where?: tbPengurusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbPenguruses to fetch.
     */
    orderBy?: tbPengurusOrderByWithRelationInput | tbPengurusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbPenguruses.
     */
    cursor?: tbPengurusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbPenguruses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbPenguruses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbPenguruses.
     */
    distinct?: TbPengurusScalarFieldEnum | TbPengurusScalarFieldEnum[]
  }

  /**
   * tbPengurus findMany
   */
  export type tbPengurusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbPengurus
     */
    select?: tbPengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbPengurus
     */
    omit?: tbPengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbPengurusInclude<ExtArgs> | null
    /**
     * Filter, which tbPenguruses to fetch.
     */
    where?: tbPengurusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbPenguruses to fetch.
     */
    orderBy?: tbPengurusOrderByWithRelationInput | tbPengurusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tbPenguruses.
     */
    cursor?: tbPengurusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbPenguruses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbPenguruses.
     */
    skip?: number
    distinct?: TbPengurusScalarFieldEnum | TbPengurusScalarFieldEnum[]
  }

  /**
   * tbPengurus create
   */
  export type tbPengurusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbPengurus
     */
    select?: tbPengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbPengurus
     */
    omit?: tbPengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbPengurusInclude<ExtArgs> | null
    /**
     * The data needed to create a tbPengurus.
     */
    data: XOR<tbPengurusCreateInput, tbPengurusUncheckedCreateInput>
  }

  /**
   * tbPengurus createMany
   */
  export type tbPengurusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tbPenguruses.
     */
    data: tbPengurusCreateManyInput | tbPengurusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tbPengurus update
   */
  export type tbPengurusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbPengurus
     */
    select?: tbPengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbPengurus
     */
    omit?: tbPengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbPengurusInclude<ExtArgs> | null
    /**
     * The data needed to update a tbPengurus.
     */
    data: XOR<tbPengurusUpdateInput, tbPengurusUncheckedUpdateInput>
    /**
     * Choose, which tbPengurus to update.
     */
    where: tbPengurusWhereUniqueInput
  }

  /**
   * tbPengurus updateMany
   */
  export type tbPengurusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tbPenguruses.
     */
    data: XOR<tbPengurusUpdateManyMutationInput, tbPengurusUncheckedUpdateManyInput>
    /**
     * Filter which tbPenguruses to update
     */
    where?: tbPengurusWhereInput
    /**
     * Limit how many tbPenguruses to update.
     */
    limit?: number
  }

  /**
   * tbPengurus upsert
   */
  export type tbPengurusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbPengurus
     */
    select?: tbPengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbPengurus
     */
    omit?: tbPengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbPengurusInclude<ExtArgs> | null
    /**
     * The filter to search for the tbPengurus to update in case it exists.
     */
    where: tbPengurusWhereUniqueInput
    /**
     * In case the tbPengurus found by the `where` argument doesn't exist, create a new tbPengurus with this data.
     */
    create: XOR<tbPengurusCreateInput, tbPengurusUncheckedCreateInput>
    /**
     * In case the tbPengurus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tbPengurusUpdateInput, tbPengurusUncheckedUpdateInput>
  }

  /**
   * tbPengurus delete
   */
  export type tbPengurusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbPengurus
     */
    select?: tbPengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbPengurus
     */
    omit?: tbPengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbPengurusInclude<ExtArgs> | null
    /**
     * Filter which tbPengurus to delete.
     */
    where: tbPengurusWhereUniqueInput
  }

  /**
   * tbPengurus deleteMany
   */
  export type tbPengurusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tbPenguruses to delete
     */
    where?: tbPengurusWhereInput
    /**
     * Limit how many tbPenguruses to delete.
     */
    limit?: number
  }

  /**
   * tbPengurus.detail_pengurus
   */
  export type tbPengurus$detail_pengurusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbDetail_Pengurus
     */
    select?: tbDetail_PengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbDetail_Pengurus
     */
    omit?: tbDetail_PengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbDetail_PengurusInclude<ExtArgs> | null
    where?: tbDetail_PengurusWhereInput
    orderBy?: tbDetail_PengurusOrderByWithRelationInput | tbDetail_PengurusOrderByWithRelationInput[]
    cursor?: tbDetail_PengurusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TbDetail_PengurusScalarFieldEnum | TbDetail_PengurusScalarFieldEnum[]
  }

  /**
   * tbPengurus without action
   */
  export type tbPengurusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tbPengurus
     */
    select?: tbPengurusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tbPengurus
     */
    omit?: tbPengurusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tbPengurusInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    kode_sup: string | null
    nama: string | null
    alamat: string | null
    no_HP: string | null
    perusahaan: string | null
    aktif: $Enums.StatusAktif | null
  }

  export type SupplierMaxAggregateOutputType = {
    kode_sup: string | null
    nama: string | null
    alamat: string | null
    no_HP: string | null
    perusahaan: string | null
    aktif: $Enums.StatusAktif | null
  }

  export type SupplierCountAggregateOutputType = {
    kode_sup: number
    nama: number
    alamat: number
    no_HP: number
    perusahaan: number
    aktif: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    kode_sup?: true
    nama?: true
    alamat?: true
    no_HP?: true
    perusahaan?: true
    aktif?: true
  }

  export type SupplierMaxAggregateInputType = {
    kode_sup?: true
    nama?: true
    alamat?: true
    no_HP?: true
    perusahaan?: true
    aktif?: true
  }

  export type SupplierCountAggregateInputType = {
    kode_sup?: true
    nama?: true
    alamat?: true
    no_HP?: true
    perusahaan?: true
    aktif?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    kode_sup: string
    nama: string
    alamat: string
    no_HP: string
    perusahaan: string
    aktif: $Enums.StatusAktif
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    kode_sup?: boolean
    nama?: boolean
    alamat?: boolean
    no_HP?: boolean
    perusahaan?: boolean
    aktif?: boolean
  }, ExtArgs["result"]["supplier"]>



  export type SupplierSelectScalar = {
    kode_sup?: boolean
    nama?: boolean
    alamat?: boolean
    no_HP?: boolean
    perusahaan?: boolean
    aktif?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"kode_sup" | "nama" | "alamat" | "no_HP" | "perusahaan" | "aktif", ExtArgs["result"]["supplier"]>

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      kode_sup: string
      nama: string
      alamat: string
      no_HP: string
      perusahaan: string
      aktif: $Enums.StatusAktif
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `kode_sup`
     * const supplierWithKode_supOnly = await prisma.supplier.findMany({ select: { kode_sup: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly kode_sup: FieldRef<"Supplier", 'String'>
    readonly nama: FieldRef<"Supplier", 'String'>
    readonly alamat: FieldRef<"Supplier", 'String'>
    readonly no_HP: FieldRef<"Supplier", 'String'>
    readonly perusahaan: FieldRef<"Supplier", 'String'>
    readonly aktif: FieldRef<"Supplier", 'StatusAktif'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
  }


  /**
   * Model Petugas
   */

  export type AggregatePetugas = {
    _count: PetugasCountAggregateOutputType | null
    _min: PetugasMinAggregateOutputType | null
    _max: PetugasMaxAggregateOutputType | null
  }

  export type PetugasMinAggregateOutputType = {
    kode_petugas: string | null
    nama: string | null
    no_hp: string | null
    username: string | null
    pass: string | null
    aktif: $Enums.StatusAktif | null
    level: $Enums.UserLevel | null
  }

  export type PetugasMaxAggregateOutputType = {
    kode_petugas: string | null
    nama: string | null
    no_hp: string | null
    username: string | null
    pass: string | null
    aktif: $Enums.StatusAktif | null
    level: $Enums.UserLevel | null
  }

  export type PetugasCountAggregateOutputType = {
    kode_petugas: number
    nama: number
    no_hp: number
    username: number
    pass: number
    aktif: number
    level: number
    _all: number
  }


  export type PetugasMinAggregateInputType = {
    kode_petugas?: true
    nama?: true
    no_hp?: true
    username?: true
    pass?: true
    aktif?: true
    level?: true
  }

  export type PetugasMaxAggregateInputType = {
    kode_petugas?: true
    nama?: true
    no_hp?: true
    username?: true
    pass?: true
    aktif?: true
    level?: true
  }

  export type PetugasCountAggregateInputType = {
    kode_petugas?: true
    nama?: true
    no_hp?: true
    username?: true
    pass?: true
    aktif?: true
    level?: true
    _all?: true
  }

  export type PetugasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Petugas to aggregate.
     */
    where?: PetugasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Petugases to fetch.
     */
    orderBy?: PetugasOrderByWithRelationInput | PetugasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PetugasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Petugases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Petugases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Petugases
    **/
    _count?: true | PetugasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PetugasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PetugasMaxAggregateInputType
  }

  export type GetPetugasAggregateType<T extends PetugasAggregateArgs> = {
        [P in keyof T & keyof AggregatePetugas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePetugas[P]>
      : GetScalarType<T[P], AggregatePetugas[P]>
  }




  export type PetugasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetugasWhereInput
    orderBy?: PetugasOrderByWithAggregationInput | PetugasOrderByWithAggregationInput[]
    by: PetugasScalarFieldEnum[] | PetugasScalarFieldEnum
    having?: PetugasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PetugasCountAggregateInputType | true
    _min?: PetugasMinAggregateInputType
    _max?: PetugasMaxAggregateInputType
  }

  export type PetugasGroupByOutputType = {
    kode_petugas: string
    nama: string
    no_hp: string
    username: string
    pass: string
    aktif: $Enums.StatusAktif
    level: $Enums.UserLevel
    _count: PetugasCountAggregateOutputType | null
    _min: PetugasMinAggregateOutputType | null
    _max: PetugasMaxAggregateOutputType | null
  }

  type GetPetugasGroupByPayload<T extends PetugasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PetugasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PetugasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PetugasGroupByOutputType[P]>
            : GetScalarType<T[P], PetugasGroupByOutputType[P]>
        }
      >
    >


  export type PetugasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    kode_petugas?: boolean
    nama?: boolean
    no_hp?: boolean
    username?: boolean
    pass?: boolean
    aktif?: boolean
    level?: boolean
  }, ExtArgs["result"]["petugas"]>



  export type PetugasSelectScalar = {
    kode_petugas?: boolean
    nama?: boolean
    no_hp?: boolean
    username?: boolean
    pass?: boolean
    aktif?: boolean
    level?: boolean
  }

  export type PetugasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"kode_petugas" | "nama" | "no_hp" | "username" | "pass" | "aktif" | "level", ExtArgs["result"]["petugas"]>

  export type $PetugasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Petugas"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      kode_petugas: string
      nama: string
      no_hp: string
      username: string
      pass: string
      aktif: $Enums.StatusAktif
      level: $Enums.UserLevel
    }, ExtArgs["result"]["petugas"]>
    composites: {}
  }

  type PetugasGetPayload<S extends boolean | null | undefined | PetugasDefaultArgs> = $Result.GetResult<Prisma.$PetugasPayload, S>

  type PetugasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PetugasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PetugasCountAggregateInputType | true
    }

  export interface PetugasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Petugas'], meta: { name: 'Petugas' } }
    /**
     * Find zero or one Petugas that matches the filter.
     * @param {PetugasFindUniqueArgs} args - Arguments to find a Petugas
     * @example
     * // Get one Petugas
     * const petugas = await prisma.petugas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PetugasFindUniqueArgs>(args: SelectSubset<T, PetugasFindUniqueArgs<ExtArgs>>): Prisma__PetugasClient<$Result.GetResult<Prisma.$PetugasPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Petugas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PetugasFindUniqueOrThrowArgs} args - Arguments to find a Petugas
     * @example
     * // Get one Petugas
     * const petugas = await prisma.petugas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PetugasFindUniqueOrThrowArgs>(args: SelectSubset<T, PetugasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PetugasClient<$Result.GetResult<Prisma.$PetugasPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Petugas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetugasFindFirstArgs} args - Arguments to find a Petugas
     * @example
     * // Get one Petugas
     * const petugas = await prisma.petugas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PetugasFindFirstArgs>(args?: SelectSubset<T, PetugasFindFirstArgs<ExtArgs>>): Prisma__PetugasClient<$Result.GetResult<Prisma.$PetugasPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Petugas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetugasFindFirstOrThrowArgs} args - Arguments to find a Petugas
     * @example
     * // Get one Petugas
     * const petugas = await prisma.petugas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PetugasFindFirstOrThrowArgs>(args?: SelectSubset<T, PetugasFindFirstOrThrowArgs<ExtArgs>>): Prisma__PetugasClient<$Result.GetResult<Prisma.$PetugasPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Petugases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetugasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Petugases
     * const petugases = await prisma.petugas.findMany()
     * 
     * // Get first 10 Petugases
     * const petugases = await prisma.petugas.findMany({ take: 10 })
     * 
     * // Only select the `kode_petugas`
     * const petugasWithKode_petugasOnly = await prisma.petugas.findMany({ select: { kode_petugas: true } })
     * 
     */
    findMany<T extends PetugasFindManyArgs>(args?: SelectSubset<T, PetugasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetugasPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Petugas.
     * @param {PetugasCreateArgs} args - Arguments to create a Petugas.
     * @example
     * // Create one Petugas
     * const Petugas = await prisma.petugas.create({
     *   data: {
     *     // ... data to create a Petugas
     *   }
     * })
     * 
     */
    create<T extends PetugasCreateArgs>(args: SelectSubset<T, PetugasCreateArgs<ExtArgs>>): Prisma__PetugasClient<$Result.GetResult<Prisma.$PetugasPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Petugases.
     * @param {PetugasCreateManyArgs} args - Arguments to create many Petugases.
     * @example
     * // Create many Petugases
     * const petugas = await prisma.petugas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PetugasCreateManyArgs>(args?: SelectSubset<T, PetugasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Petugas.
     * @param {PetugasDeleteArgs} args - Arguments to delete one Petugas.
     * @example
     * // Delete one Petugas
     * const Petugas = await prisma.petugas.delete({
     *   where: {
     *     // ... filter to delete one Petugas
     *   }
     * })
     * 
     */
    delete<T extends PetugasDeleteArgs>(args: SelectSubset<T, PetugasDeleteArgs<ExtArgs>>): Prisma__PetugasClient<$Result.GetResult<Prisma.$PetugasPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Petugas.
     * @param {PetugasUpdateArgs} args - Arguments to update one Petugas.
     * @example
     * // Update one Petugas
     * const petugas = await prisma.petugas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PetugasUpdateArgs>(args: SelectSubset<T, PetugasUpdateArgs<ExtArgs>>): Prisma__PetugasClient<$Result.GetResult<Prisma.$PetugasPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Petugases.
     * @param {PetugasDeleteManyArgs} args - Arguments to filter Petugases to delete.
     * @example
     * // Delete a few Petugases
     * const { count } = await prisma.petugas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PetugasDeleteManyArgs>(args?: SelectSubset<T, PetugasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Petugases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetugasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Petugases
     * const petugas = await prisma.petugas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PetugasUpdateManyArgs>(args: SelectSubset<T, PetugasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Petugas.
     * @param {PetugasUpsertArgs} args - Arguments to update or create a Petugas.
     * @example
     * // Update or create a Petugas
     * const petugas = await prisma.petugas.upsert({
     *   create: {
     *     // ... data to create a Petugas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Petugas we want to update
     *   }
     * })
     */
    upsert<T extends PetugasUpsertArgs>(args: SelectSubset<T, PetugasUpsertArgs<ExtArgs>>): Prisma__PetugasClient<$Result.GetResult<Prisma.$PetugasPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Petugases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetugasCountArgs} args - Arguments to filter Petugases to count.
     * @example
     * // Count the number of Petugases
     * const count = await prisma.petugas.count({
     *   where: {
     *     // ... the filter for the Petugases we want to count
     *   }
     * })
    **/
    count<T extends PetugasCountArgs>(
      args?: Subset<T, PetugasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PetugasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Petugas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetugasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PetugasAggregateArgs>(args: Subset<T, PetugasAggregateArgs>): Prisma.PrismaPromise<GetPetugasAggregateType<T>>

    /**
     * Group by Petugas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetugasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PetugasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PetugasGroupByArgs['orderBy'] }
        : { orderBy?: PetugasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PetugasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPetugasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Petugas model
   */
  readonly fields: PetugasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Petugas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PetugasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Petugas model
   */ 
  interface PetugasFieldRefs {
    readonly kode_petugas: FieldRef<"Petugas", 'String'>
    readonly nama: FieldRef<"Petugas", 'String'>
    readonly no_hp: FieldRef<"Petugas", 'String'>
    readonly username: FieldRef<"Petugas", 'String'>
    readonly pass: FieldRef<"Petugas", 'String'>
    readonly aktif: FieldRef<"Petugas", 'StatusAktif'>
    readonly level: FieldRef<"Petugas", 'UserLevel'>
  }
    

  // Custom InputTypes
  /**
   * Petugas findUnique
   */
  export type PetugasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Petugas
     */
    select?: PetugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Petugas
     */
    omit?: PetugasOmit<ExtArgs> | null
    /**
     * Filter, which Petugas to fetch.
     */
    where: PetugasWhereUniqueInput
  }

  /**
   * Petugas findUniqueOrThrow
   */
  export type PetugasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Petugas
     */
    select?: PetugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Petugas
     */
    omit?: PetugasOmit<ExtArgs> | null
    /**
     * Filter, which Petugas to fetch.
     */
    where: PetugasWhereUniqueInput
  }

  /**
   * Petugas findFirst
   */
  export type PetugasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Petugas
     */
    select?: PetugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Petugas
     */
    omit?: PetugasOmit<ExtArgs> | null
    /**
     * Filter, which Petugas to fetch.
     */
    where?: PetugasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Petugases to fetch.
     */
    orderBy?: PetugasOrderByWithRelationInput | PetugasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Petugases.
     */
    cursor?: PetugasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Petugases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Petugases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Petugases.
     */
    distinct?: PetugasScalarFieldEnum | PetugasScalarFieldEnum[]
  }

  /**
   * Petugas findFirstOrThrow
   */
  export type PetugasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Petugas
     */
    select?: PetugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Petugas
     */
    omit?: PetugasOmit<ExtArgs> | null
    /**
     * Filter, which Petugas to fetch.
     */
    where?: PetugasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Petugases to fetch.
     */
    orderBy?: PetugasOrderByWithRelationInput | PetugasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Petugases.
     */
    cursor?: PetugasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Petugases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Petugases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Petugases.
     */
    distinct?: PetugasScalarFieldEnum | PetugasScalarFieldEnum[]
  }

  /**
   * Petugas findMany
   */
  export type PetugasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Petugas
     */
    select?: PetugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Petugas
     */
    omit?: PetugasOmit<ExtArgs> | null
    /**
     * Filter, which Petugases to fetch.
     */
    where?: PetugasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Petugases to fetch.
     */
    orderBy?: PetugasOrderByWithRelationInput | PetugasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Petugases.
     */
    cursor?: PetugasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Petugases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Petugases.
     */
    skip?: number
    distinct?: PetugasScalarFieldEnum | PetugasScalarFieldEnum[]
  }

  /**
   * Petugas create
   */
  export type PetugasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Petugas
     */
    select?: PetugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Petugas
     */
    omit?: PetugasOmit<ExtArgs> | null
    /**
     * The data needed to create a Petugas.
     */
    data: XOR<PetugasCreateInput, PetugasUncheckedCreateInput>
  }

  /**
   * Petugas createMany
   */
  export type PetugasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Petugases.
     */
    data: PetugasCreateManyInput | PetugasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Petugas update
   */
  export type PetugasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Petugas
     */
    select?: PetugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Petugas
     */
    omit?: PetugasOmit<ExtArgs> | null
    /**
     * The data needed to update a Petugas.
     */
    data: XOR<PetugasUpdateInput, PetugasUncheckedUpdateInput>
    /**
     * Choose, which Petugas to update.
     */
    where: PetugasWhereUniqueInput
  }

  /**
   * Petugas updateMany
   */
  export type PetugasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Petugases.
     */
    data: XOR<PetugasUpdateManyMutationInput, PetugasUncheckedUpdateManyInput>
    /**
     * Filter which Petugases to update
     */
    where?: PetugasWhereInput
    /**
     * Limit how many Petugases to update.
     */
    limit?: number
  }

  /**
   * Petugas upsert
   */
  export type PetugasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Petugas
     */
    select?: PetugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Petugas
     */
    omit?: PetugasOmit<ExtArgs> | null
    /**
     * The filter to search for the Petugas to update in case it exists.
     */
    where: PetugasWhereUniqueInput
    /**
     * In case the Petugas found by the `where` argument doesn't exist, create a new Petugas with this data.
     */
    create: XOR<PetugasCreateInput, PetugasUncheckedCreateInput>
    /**
     * In case the Petugas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PetugasUpdateInput, PetugasUncheckedUpdateInput>
  }

  /**
   * Petugas delete
   */
  export type PetugasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Petugas
     */
    select?: PetugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Petugas
     */
    omit?: PetugasOmit<ExtArgs> | null
    /**
     * Filter which Petugas to delete.
     */
    where: PetugasWhereUniqueInput
  }

  /**
   * Petugas deleteMany
   */
  export type PetugasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Petugases to delete
     */
    where?: PetugasWhereInput
    /**
     * Limit how many Petugases to delete.
     */
    limit?: number
  }

  /**
   * Petugas without action
   */
  export type PetugasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Petugas
     */
    select?: PetugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Petugas
     */
    omit?: PetugasOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TbKategoriScalarFieldEnum: {
    kode_kategori: 'kode_kategori',
    nama: 'nama',
    aktif: 'aktif'
  };

  export type TbKategoriScalarFieldEnum = (typeof TbKategoriScalarFieldEnum)[keyof typeof TbKategoriScalarFieldEnum]


  export const TbBarangScalarFieldEnum: {
    kode_barang: 'kode_barang',
    nama_barang: 'nama_barang',
    hargaBeli: 'hargaBeli',
    hargaEcer: 'hargaEcer',
    hargaGrosir: 'hargaGrosir',
    stock: 'stock',
    stock_min: 'stock_min',
    barcode: 'barcode',
    gambar: 'gambar',
    kode_kategori: 'kode_kategori',
    ukuran: 'ukuran',
    satuan: 'satuan',
    aktif: 'aktif'
  };

  export type TbBarangScalarFieldEnum = (typeof TbBarangScalarFieldEnum)[keyof typeof TbBarangScalarFieldEnum]


  export const TbSatuanScalarFieldEnum: {
    kode_satuan: 'kode_satuan',
    nama: 'nama',
    aktif: 'aktif'
  };

  export type TbSatuanScalarFieldEnum = (typeof TbSatuanScalarFieldEnum)[keyof typeof TbSatuanScalarFieldEnum]


  export const TbAnggotaScalarFieldEnum: {
    NIP: 'NIP',
    Nama_Anggota: 'Nama_Anggota',
    Nomor_rekening: 'Nomor_rekening',
    bank: 'bank',
    no_hp: 'no_hp',
    Alamat: 'Alamat',
    Limit_Piutang: 'Limit_Piutang',
    aktif: 'aktif'
  };

  export type TbAnggotaScalarFieldEnum = (typeof TbAnggotaScalarFieldEnum)[keyof typeof TbAnggotaScalarFieldEnum]


  export const TbDetail_PengurusScalarFieldEnum: {
    kode_detail: 'kode_detail',
    tahun: 'tahun',
    nip: 'nip',
    kode_pengurus: 'kode_pengurus',
    tgl_menjabat: 'tgl_menjabat',
    tgl_akhirmenjabat: 'tgl_akhirmenjabat',
    tunjangan: 'tunjangan',
    aktif: 'aktif'
  };

  export type TbDetail_PengurusScalarFieldEnum = (typeof TbDetail_PengurusScalarFieldEnum)[keyof typeof TbDetail_PengurusScalarFieldEnum]


  export const TbPengurusScalarFieldEnum: {
    kode_pengurus: 'kode_pengurus',
    nama: 'nama',
    aktif: 'aktif'
  };

  export type TbPengurusScalarFieldEnum = (typeof TbPengurusScalarFieldEnum)[keyof typeof TbPengurusScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    kode_sup: 'kode_sup',
    nama: 'nama',
    alamat: 'alamat',
    no_HP: 'no_HP',
    perusahaan: 'perusahaan',
    aktif: 'aktif'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const PetugasScalarFieldEnum: {
    kode_petugas: 'kode_petugas',
    nama: 'nama',
    no_hp: 'no_hp',
    username: 'username',
    pass: 'pass',
    aktif: 'aktif',
    level: 'level'
  };

  export type PetugasScalarFieldEnum = (typeof PetugasScalarFieldEnum)[keyof typeof PetugasScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const tbKategoriOrderByRelevanceFieldEnum: {
    kode_kategori: 'kode_kategori',
    nama: 'nama'
  };

  export type tbKategoriOrderByRelevanceFieldEnum = (typeof tbKategoriOrderByRelevanceFieldEnum)[keyof typeof tbKategoriOrderByRelevanceFieldEnum]


  export const tbBarangOrderByRelevanceFieldEnum: {
    kode_barang: 'kode_barang',
    nama_barang: 'nama_barang',
    barcode: 'barcode',
    gambar: 'gambar',
    kode_kategori: 'kode_kategori',
    satuan: 'satuan'
  };

  export type tbBarangOrderByRelevanceFieldEnum = (typeof tbBarangOrderByRelevanceFieldEnum)[keyof typeof tbBarangOrderByRelevanceFieldEnum]


  export const tbSatuanOrderByRelevanceFieldEnum: {
    kode_satuan: 'kode_satuan',
    nama: 'nama'
  };

  export type tbSatuanOrderByRelevanceFieldEnum = (typeof tbSatuanOrderByRelevanceFieldEnum)[keyof typeof tbSatuanOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const tbAnggotaOrderByRelevanceFieldEnum: {
    NIP: 'NIP',
    Nama_Anggota: 'Nama_Anggota',
    Nomor_rekening: 'Nomor_rekening',
    bank: 'bank',
    no_hp: 'no_hp',
    Alamat: 'Alamat'
  };

  export type tbAnggotaOrderByRelevanceFieldEnum = (typeof tbAnggotaOrderByRelevanceFieldEnum)[keyof typeof tbAnggotaOrderByRelevanceFieldEnum]


  export const tbDetail_PengurusOrderByRelevanceFieldEnum: {
    kode_detail: 'kode_detail',
    nip: 'nip',
    kode_pengurus: 'kode_pengurus'
  };

  export type tbDetail_PengurusOrderByRelevanceFieldEnum = (typeof tbDetail_PengurusOrderByRelevanceFieldEnum)[keyof typeof tbDetail_PengurusOrderByRelevanceFieldEnum]


  export const tbPengurusOrderByRelevanceFieldEnum: {
    kode_pengurus: 'kode_pengurus',
    nama: 'nama'
  };

  export type tbPengurusOrderByRelevanceFieldEnum = (typeof tbPengurusOrderByRelevanceFieldEnum)[keyof typeof tbPengurusOrderByRelevanceFieldEnum]


  export const SupplierOrderByRelevanceFieldEnum: {
    kode_sup: 'kode_sup',
    nama: 'nama',
    alamat: 'alamat',
    no_HP: 'no_HP',
    perusahaan: 'perusahaan'
  };

  export type SupplierOrderByRelevanceFieldEnum = (typeof SupplierOrderByRelevanceFieldEnum)[keyof typeof SupplierOrderByRelevanceFieldEnum]


  export const PetugasOrderByRelevanceFieldEnum: {
    kode_petugas: 'kode_petugas',
    nama: 'nama',
    no_hp: 'no_hp',
    username: 'username',
    pass: 'pass'
  };

  export type PetugasOrderByRelevanceFieldEnum = (typeof PetugasOrderByRelevanceFieldEnum)[keyof typeof PetugasOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'StatusAktif'
   */
  export type EnumStatusAktifFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusAktif'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'UserLevel'
   */
  export type EnumUserLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserLevel'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type tbKategoriWhereInput = {
    AND?: tbKategoriWhereInput | tbKategoriWhereInput[]
    OR?: tbKategoriWhereInput[]
    NOT?: tbKategoriWhereInput | tbKategoriWhereInput[]
    kode_kategori?: StringFilter<"tbKategori"> | string
    nama?: StringFilter<"tbKategori"> | string
    aktif?: EnumStatusAktifFilter<"tbKategori"> | $Enums.StatusAktif
    barang?: TbBarangListRelationFilter
  }

  export type tbKategoriOrderByWithRelationInput = {
    kode_kategori?: SortOrder
    nama?: SortOrder
    aktif?: SortOrder
    barang?: tbBarangOrderByRelationAggregateInput
    _relevance?: tbKategoriOrderByRelevanceInput
  }

  export type tbKategoriWhereUniqueInput = Prisma.AtLeast<{
    kode_kategori?: string
    AND?: tbKategoriWhereInput | tbKategoriWhereInput[]
    OR?: tbKategoriWhereInput[]
    NOT?: tbKategoriWhereInput | tbKategoriWhereInput[]
    nama?: StringFilter<"tbKategori"> | string
    aktif?: EnumStatusAktifFilter<"tbKategori"> | $Enums.StatusAktif
    barang?: TbBarangListRelationFilter
  }, "kode_kategori">

  export type tbKategoriOrderByWithAggregationInput = {
    kode_kategori?: SortOrder
    nama?: SortOrder
    aktif?: SortOrder
    _count?: tbKategoriCountOrderByAggregateInput
    _max?: tbKategoriMaxOrderByAggregateInput
    _min?: tbKategoriMinOrderByAggregateInput
  }

  export type tbKategoriScalarWhereWithAggregatesInput = {
    AND?: tbKategoriScalarWhereWithAggregatesInput | tbKategoriScalarWhereWithAggregatesInput[]
    OR?: tbKategoriScalarWhereWithAggregatesInput[]
    NOT?: tbKategoriScalarWhereWithAggregatesInput | tbKategoriScalarWhereWithAggregatesInput[]
    kode_kategori?: StringWithAggregatesFilter<"tbKategori"> | string
    nama?: StringWithAggregatesFilter<"tbKategori"> | string
    aktif?: EnumStatusAktifWithAggregatesFilter<"tbKategori"> | $Enums.StatusAktif
  }

  export type tbBarangWhereInput = {
    AND?: tbBarangWhereInput | tbBarangWhereInput[]
    OR?: tbBarangWhereInput[]
    NOT?: tbBarangWhereInput | tbBarangWhereInput[]
    kode_barang?: StringFilter<"tbBarang"> | string
    nama_barang?: StringFilter<"tbBarang"> | string
    hargaBeli?: IntFilter<"tbBarang"> | number
    hargaEcer?: IntFilter<"tbBarang"> | number
    hargaGrosir?: IntFilter<"tbBarang"> | number
    stock?: IntFilter<"tbBarang"> | number
    stock_min?: IntFilter<"tbBarang"> | number
    barcode?: StringFilter<"tbBarang"> | string
    gambar?: StringFilter<"tbBarang"> | string
    kode_kategori?: StringFilter<"tbBarang"> | string
    ukuran?: IntFilter<"tbBarang"> | number
    satuan?: StringFilter<"tbBarang"> | string
    aktif?: EnumStatusAktifFilter<"tbBarang"> | $Enums.StatusAktif
    kategori?: XOR<TbKategoriScalarRelationFilter, tbKategoriWhereInput>
  }

  export type tbBarangOrderByWithRelationInput = {
    kode_barang?: SortOrder
    nama_barang?: SortOrder
    hargaBeli?: SortOrder
    hargaEcer?: SortOrder
    hargaGrosir?: SortOrder
    stock?: SortOrder
    stock_min?: SortOrder
    barcode?: SortOrder
    gambar?: SortOrder
    kode_kategori?: SortOrder
    ukuran?: SortOrder
    satuan?: SortOrder
    aktif?: SortOrder
    kategori?: tbKategoriOrderByWithRelationInput
    _relevance?: tbBarangOrderByRelevanceInput
  }

  export type tbBarangWhereUniqueInput = Prisma.AtLeast<{
    kode_barang?: string
    barcode?: string
    AND?: tbBarangWhereInput | tbBarangWhereInput[]
    OR?: tbBarangWhereInput[]
    NOT?: tbBarangWhereInput | tbBarangWhereInput[]
    nama_barang?: StringFilter<"tbBarang"> | string
    hargaBeli?: IntFilter<"tbBarang"> | number
    hargaEcer?: IntFilter<"tbBarang"> | number
    hargaGrosir?: IntFilter<"tbBarang"> | number
    stock?: IntFilter<"tbBarang"> | number
    stock_min?: IntFilter<"tbBarang"> | number
    gambar?: StringFilter<"tbBarang"> | string
    kode_kategori?: StringFilter<"tbBarang"> | string
    ukuran?: IntFilter<"tbBarang"> | number
    satuan?: StringFilter<"tbBarang"> | string
    aktif?: EnumStatusAktifFilter<"tbBarang"> | $Enums.StatusAktif
    kategori?: XOR<TbKategoriScalarRelationFilter, tbKategoriWhereInput>
  }, "kode_barang" | "barcode">

  export type tbBarangOrderByWithAggregationInput = {
    kode_barang?: SortOrder
    nama_barang?: SortOrder
    hargaBeli?: SortOrder
    hargaEcer?: SortOrder
    hargaGrosir?: SortOrder
    stock?: SortOrder
    stock_min?: SortOrder
    barcode?: SortOrder
    gambar?: SortOrder
    kode_kategori?: SortOrder
    ukuran?: SortOrder
    satuan?: SortOrder
    aktif?: SortOrder
    _count?: tbBarangCountOrderByAggregateInput
    _avg?: tbBarangAvgOrderByAggregateInput
    _max?: tbBarangMaxOrderByAggregateInput
    _min?: tbBarangMinOrderByAggregateInput
    _sum?: tbBarangSumOrderByAggregateInput
  }

  export type tbBarangScalarWhereWithAggregatesInput = {
    AND?: tbBarangScalarWhereWithAggregatesInput | tbBarangScalarWhereWithAggregatesInput[]
    OR?: tbBarangScalarWhereWithAggregatesInput[]
    NOT?: tbBarangScalarWhereWithAggregatesInput | tbBarangScalarWhereWithAggregatesInput[]
    kode_barang?: StringWithAggregatesFilter<"tbBarang"> | string
    nama_barang?: StringWithAggregatesFilter<"tbBarang"> | string
    hargaBeli?: IntWithAggregatesFilter<"tbBarang"> | number
    hargaEcer?: IntWithAggregatesFilter<"tbBarang"> | number
    hargaGrosir?: IntWithAggregatesFilter<"tbBarang"> | number
    stock?: IntWithAggregatesFilter<"tbBarang"> | number
    stock_min?: IntWithAggregatesFilter<"tbBarang"> | number
    barcode?: StringWithAggregatesFilter<"tbBarang"> | string
    gambar?: StringWithAggregatesFilter<"tbBarang"> | string
    kode_kategori?: StringWithAggregatesFilter<"tbBarang"> | string
    ukuran?: IntWithAggregatesFilter<"tbBarang"> | number
    satuan?: StringWithAggregatesFilter<"tbBarang"> | string
    aktif?: EnumStatusAktifWithAggregatesFilter<"tbBarang"> | $Enums.StatusAktif
  }

  export type tbSatuanWhereInput = {
    AND?: tbSatuanWhereInput | tbSatuanWhereInput[]
    OR?: tbSatuanWhereInput[]
    NOT?: tbSatuanWhereInput | tbSatuanWhereInput[]
    kode_satuan?: StringFilter<"tbSatuan"> | string
    nama?: StringFilter<"tbSatuan"> | string
    aktif?: EnumStatusAktifFilter<"tbSatuan"> | $Enums.StatusAktif
  }

  export type tbSatuanOrderByWithRelationInput = {
    kode_satuan?: SortOrder
    nama?: SortOrder
    aktif?: SortOrder
    _relevance?: tbSatuanOrderByRelevanceInput
  }

  export type tbSatuanWhereUniqueInput = Prisma.AtLeast<{
    kode_satuan?: string
    AND?: tbSatuanWhereInput | tbSatuanWhereInput[]
    OR?: tbSatuanWhereInput[]
    NOT?: tbSatuanWhereInput | tbSatuanWhereInput[]
    nama?: StringFilter<"tbSatuan"> | string
    aktif?: EnumStatusAktifFilter<"tbSatuan"> | $Enums.StatusAktif
  }, "kode_satuan">

  export type tbSatuanOrderByWithAggregationInput = {
    kode_satuan?: SortOrder
    nama?: SortOrder
    aktif?: SortOrder
    _count?: tbSatuanCountOrderByAggregateInput
    _max?: tbSatuanMaxOrderByAggregateInput
    _min?: tbSatuanMinOrderByAggregateInput
  }

  export type tbSatuanScalarWhereWithAggregatesInput = {
    AND?: tbSatuanScalarWhereWithAggregatesInput | tbSatuanScalarWhereWithAggregatesInput[]
    OR?: tbSatuanScalarWhereWithAggregatesInput[]
    NOT?: tbSatuanScalarWhereWithAggregatesInput | tbSatuanScalarWhereWithAggregatesInput[]
    kode_satuan?: StringWithAggregatesFilter<"tbSatuan"> | string
    nama?: StringWithAggregatesFilter<"tbSatuan"> | string
    aktif?: EnumStatusAktifWithAggregatesFilter<"tbSatuan"> | $Enums.StatusAktif
  }

  export type tbAnggotaWhereInput = {
    AND?: tbAnggotaWhereInput | tbAnggotaWhereInput[]
    OR?: tbAnggotaWhereInput[]
    NOT?: tbAnggotaWhereInput | tbAnggotaWhereInput[]
    NIP?: StringFilter<"tbAnggota"> | string
    Nama_Anggota?: StringNullableFilter<"tbAnggota"> | string | null
    Nomor_rekening?: StringFilter<"tbAnggota"> | string
    bank?: StringFilter<"tbAnggota"> | string
    no_hp?: StringFilter<"tbAnggota"> | string
    Alamat?: StringFilter<"tbAnggota"> | string
    Limit_Piutang?: IntFilter<"tbAnggota"> | number
    aktif?: EnumStatusAktifFilter<"tbAnggota"> | $Enums.StatusAktif
  }

  export type tbAnggotaOrderByWithRelationInput = {
    NIP?: SortOrder
    Nama_Anggota?: SortOrderInput | SortOrder
    Nomor_rekening?: SortOrder
    bank?: SortOrder
    no_hp?: SortOrder
    Alamat?: SortOrder
    Limit_Piutang?: SortOrder
    aktif?: SortOrder
    _relevance?: tbAnggotaOrderByRelevanceInput
  }

  export type tbAnggotaWhereUniqueInput = Prisma.AtLeast<{
    NIP?: string
    Nomor_rekening?: string
    AND?: tbAnggotaWhereInput | tbAnggotaWhereInput[]
    OR?: tbAnggotaWhereInput[]
    NOT?: tbAnggotaWhereInput | tbAnggotaWhereInput[]
    Nama_Anggota?: StringNullableFilter<"tbAnggota"> | string | null
    bank?: StringFilter<"tbAnggota"> | string
    no_hp?: StringFilter<"tbAnggota"> | string
    Alamat?: StringFilter<"tbAnggota"> | string
    Limit_Piutang?: IntFilter<"tbAnggota"> | number
    aktif?: EnumStatusAktifFilter<"tbAnggota"> | $Enums.StatusAktif
  }, "NIP" | "Nomor_rekening">

  export type tbAnggotaOrderByWithAggregationInput = {
    NIP?: SortOrder
    Nama_Anggota?: SortOrderInput | SortOrder
    Nomor_rekening?: SortOrder
    bank?: SortOrder
    no_hp?: SortOrder
    Alamat?: SortOrder
    Limit_Piutang?: SortOrder
    aktif?: SortOrder
    _count?: tbAnggotaCountOrderByAggregateInput
    _avg?: tbAnggotaAvgOrderByAggregateInput
    _max?: tbAnggotaMaxOrderByAggregateInput
    _min?: tbAnggotaMinOrderByAggregateInput
    _sum?: tbAnggotaSumOrderByAggregateInput
  }

  export type tbAnggotaScalarWhereWithAggregatesInput = {
    AND?: tbAnggotaScalarWhereWithAggregatesInput | tbAnggotaScalarWhereWithAggregatesInput[]
    OR?: tbAnggotaScalarWhereWithAggregatesInput[]
    NOT?: tbAnggotaScalarWhereWithAggregatesInput | tbAnggotaScalarWhereWithAggregatesInput[]
    NIP?: StringWithAggregatesFilter<"tbAnggota"> | string
    Nama_Anggota?: StringNullableWithAggregatesFilter<"tbAnggota"> | string | null
    Nomor_rekening?: StringWithAggregatesFilter<"tbAnggota"> | string
    bank?: StringWithAggregatesFilter<"tbAnggota"> | string
    no_hp?: StringWithAggregatesFilter<"tbAnggota"> | string
    Alamat?: StringWithAggregatesFilter<"tbAnggota"> | string
    Limit_Piutang?: IntWithAggregatesFilter<"tbAnggota"> | number
    aktif?: EnumStatusAktifWithAggregatesFilter<"tbAnggota"> | $Enums.StatusAktif
  }

  export type tbDetail_PengurusWhereInput = {
    AND?: tbDetail_PengurusWhereInput | tbDetail_PengurusWhereInput[]
    OR?: tbDetail_PengurusWhereInput[]
    NOT?: tbDetail_PengurusWhereInput | tbDetail_PengurusWhereInput[]
    kode_detail?: StringFilter<"tbDetail_Pengurus"> | string
    tahun?: IntFilter<"tbDetail_Pengurus"> | number
    nip?: StringFilter<"tbDetail_Pengurus"> | string
    kode_pengurus?: StringFilter<"tbDetail_Pengurus"> | string
    tgl_menjabat?: DateTimeFilter<"tbDetail_Pengurus"> | Date | string
    tgl_akhirmenjabat?: DateTimeFilter<"tbDetail_Pengurus"> | Date | string
    tunjangan?: DecimalNullableFilter<"tbDetail_Pengurus"> | Decimal | DecimalJsLike | number | string | null
    aktif?: EnumStatusAktifFilter<"tbDetail_Pengurus"> | $Enums.StatusAktif
    pengurus?: XOR<TbPengurusScalarRelationFilter, tbPengurusWhereInput>
  }

  export type tbDetail_PengurusOrderByWithRelationInput = {
    kode_detail?: SortOrder
    tahun?: SortOrder
    nip?: SortOrder
    kode_pengurus?: SortOrder
    tgl_menjabat?: SortOrder
    tgl_akhirmenjabat?: SortOrder
    tunjangan?: SortOrderInput | SortOrder
    aktif?: SortOrder
    pengurus?: tbPengurusOrderByWithRelationInput
    _relevance?: tbDetail_PengurusOrderByRelevanceInput
  }

  export type tbDetail_PengurusWhereUniqueInput = Prisma.AtLeast<{
    kode_detail?: string
    AND?: tbDetail_PengurusWhereInput | tbDetail_PengurusWhereInput[]
    OR?: tbDetail_PengurusWhereInput[]
    NOT?: tbDetail_PengurusWhereInput | tbDetail_PengurusWhereInput[]
    tahun?: IntFilter<"tbDetail_Pengurus"> | number
    nip?: StringFilter<"tbDetail_Pengurus"> | string
    kode_pengurus?: StringFilter<"tbDetail_Pengurus"> | string
    tgl_menjabat?: DateTimeFilter<"tbDetail_Pengurus"> | Date | string
    tgl_akhirmenjabat?: DateTimeFilter<"tbDetail_Pengurus"> | Date | string
    tunjangan?: DecimalNullableFilter<"tbDetail_Pengurus"> | Decimal | DecimalJsLike | number | string | null
    aktif?: EnumStatusAktifFilter<"tbDetail_Pengurus"> | $Enums.StatusAktif
    pengurus?: XOR<TbPengurusScalarRelationFilter, tbPengurusWhereInput>
  }, "kode_detail">

  export type tbDetail_PengurusOrderByWithAggregationInput = {
    kode_detail?: SortOrder
    tahun?: SortOrder
    nip?: SortOrder
    kode_pengurus?: SortOrder
    tgl_menjabat?: SortOrder
    tgl_akhirmenjabat?: SortOrder
    tunjangan?: SortOrderInput | SortOrder
    aktif?: SortOrder
    _count?: tbDetail_PengurusCountOrderByAggregateInput
    _avg?: tbDetail_PengurusAvgOrderByAggregateInput
    _max?: tbDetail_PengurusMaxOrderByAggregateInput
    _min?: tbDetail_PengurusMinOrderByAggregateInput
    _sum?: tbDetail_PengurusSumOrderByAggregateInput
  }

  export type tbDetail_PengurusScalarWhereWithAggregatesInput = {
    AND?: tbDetail_PengurusScalarWhereWithAggregatesInput | tbDetail_PengurusScalarWhereWithAggregatesInput[]
    OR?: tbDetail_PengurusScalarWhereWithAggregatesInput[]
    NOT?: tbDetail_PengurusScalarWhereWithAggregatesInput | tbDetail_PengurusScalarWhereWithAggregatesInput[]
    kode_detail?: StringWithAggregatesFilter<"tbDetail_Pengurus"> | string
    tahun?: IntWithAggregatesFilter<"tbDetail_Pengurus"> | number
    nip?: StringWithAggregatesFilter<"tbDetail_Pengurus"> | string
    kode_pengurus?: StringWithAggregatesFilter<"tbDetail_Pengurus"> | string
    tgl_menjabat?: DateTimeWithAggregatesFilter<"tbDetail_Pengurus"> | Date | string
    tgl_akhirmenjabat?: DateTimeWithAggregatesFilter<"tbDetail_Pengurus"> | Date | string
    tunjangan?: DecimalNullableWithAggregatesFilter<"tbDetail_Pengurus"> | Decimal | DecimalJsLike | number | string | null
    aktif?: EnumStatusAktifWithAggregatesFilter<"tbDetail_Pengurus"> | $Enums.StatusAktif
  }

  export type tbPengurusWhereInput = {
    AND?: tbPengurusWhereInput | tbPengurusWhereInput[]
    OR?: tbPengurusWhereInput[]
    NOT?: tbPengurusWhereInput | tbPengurusWhereInput[]
    kode_pengurus?: StringFilter<"tbPengurus"> | string
    nama?: StringFilter<"tbPengurus"> | string
    aktif?: EnumStatusAktifFilter<"tbPengurus"> | $Enums.StatusAktif
    detail_pengurus?: TbDetail_PengurusListRelationFilter
  }

  export type tbPengurusOrderByWithRelationInput = {
    kode_pengurus?: SortOrder
    nama?: SortOrder
    aktif?: SortOrder
    detail_pengurus?: tbDetail_PengurusOrderByRelationAggregateInput
    _relevance?: tbPengurusOrderByRelevanceInput
  }

  export type tbPengurusWhereUniqueInput = Prisma.AtLeast<{
    kode_pengurus?: string
    AND?: tbPengurusWhereInput | tbPengurusWhereInput[]
    OR?: tbPengurusWhereInput[]
    NOT?: tbPengurusWhereInput | tbPengurusWhereInput[]
    nama?: StringFilter<"tbPengurus"> | string
    aktif?: EnumStatusAktifFilter<"tbPengurus"> | $Enums.StatusAktif
    detail_pengurus?: TbDetail_PengurusListRelationFilter
  }, "kode_pengurus">

  export type tbPengurusOrderByWithAggregationInput = {
    kode_pengurus?: SortOrder
    nama?: SortOrder
    aktif?: SortOrder
    _count?: tbPengurusCountOrderByAggregateInput
    _max?: tbPengurusMaxOrderByAggregateInput
    _min?: tbPengurusMinOrderByAggregateInput
  }

  export type tbPengurusScalarWhereWithAggregatesInput = {
    AND?: tbPengurusScalarWhereWithAggregatesInput | tbPengurusScalarWhereWithAggregatesInput[]
    OR?: tbPengurusScalarWhereWithAggregatesInput[]
    NOT?: tbPengurusScalarWhereWithAggregatesInput | tbPengurusScalarWhereWithAggregatesInput[]
    kode_pengurus?: StringWithAggregatesFilter<"tbPengurus"> | string
    nama?: StringWithAggregatesFilter<"tbPengurus"> | string
    aktif?: EnumStatusAktifWithAggregatesFilter<"tbPengurus"> | $Enums.StatusAktif
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    kode_sup?: StringFilter<"Supplier"> | string
    nama?: StringFilter<"Supplier"> | string
    alamat?: StringFilter<"Supplier"> | string
    no_HP?: StringFilter<"Supplier"> | string
    perusahaan?: StringFilter<"Supplier"> | string
    aktif?: EnumStatusAktifFilter<"Supplier"> | $Enums.StatusAktif
  }

  export type SupplierOrderByWithRelationInput = {
    kode_sup?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    no_HP?: SortOrder
    perusahaan?: SortOrder
    aktif?: SortOrder
    _relevance?: SupplierOrderByRelevanceInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    kode_sup?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    nama?: StringFilter<"Supplier"> | string
    alamat?: StringFilter<"Supplier"> | string
    no_HP?: StringFilter<"Supplier"> | string
    perusahaan?: StringFilter<"Supplier"> | string
    aktif?: EnumStatusAktifFilter<"Supplier"> | $Enums.StatusAktif
  }, "kode_sup">

  export type SupplierOrderByWithAggregationInput = {
    kode_sup?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    no_HP?: SortOrder
    perusahaan?: SortOrder
    aktif?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    kode_sup?: StringWithAggregatesFilter<"Supplier"> | string
    nama?: StringWithAggregatesFilter<"Supplier"> | string
    alamat?: StringWithAggregatesFilter<"Supplier"> | string
    no_HP?: StringWithAggregatesFilter<"Supplier"> | string
    perusahaan?: StringWithAggregatesFilter<"Supplier"> | string
    aktif?: EnumStatusAktifWithAggregatesFilter<"Supplier"> | $Enums.StatusAktif
  }

  export type PetugasWhereInput = {
    AND?: PetugasWhereInput | PetugasWhereInput[]
    OR?: PetugasWhereInput[]
    NOT?: PetugasWhereInput | PetugasWhereInput[]
    kode_petugas?: StringFilter<"Petugas"> | string
    nama?: StringFilter<"Petugas"> | string
    no_hp?: StringFilter<"Petugas"> | string
    username?: StringFilter<"Petugas"> | string
    pass?: StringFilter<"Petugas"> | string
    aktif?: EnumStatusAktifFilter<"Petugas"> | $Enums.StatusAktif
    level?: EnumUserLevelFilter<"Petugas"> | $Enums.UserLevel
  }

  export type PetugasOrderByWithRelationInput = {
    kode_petugas?: SortOrder
    nama?: SortOrder
    no_hp?: SortOrder
    username?: SortOrder
    pass?: SortOrder
    aktif?: SortOrder
    level?: SortOrder
    _relevance?: PetugasOrderByRelevanceInput
  }

  export type PetugasWhereUniqueInput = Prisma.AtLeast<{
    kode_petugas?: string
    username?: string
    AND?: PetugasWhereInput | PetugasWhereInput[]
    OR?: PetugasWhereInput[]
    NOT?: PetugasWhereInput | PetugasWhereInput[]
    nama?: StringFilter<"Petugas"> | string
    no_hp?: StringFilter<"Petugas"> | string
    pass?: StringFilter<"Petugas"> | string
    aktif?: EnumStatusAktifFilter<"Petugas"> | $Enums.StatusAktif
    level?: EnumUserLevelFilter<"Petugas"> | $Enums.UserLevel
  }, "kode_petugas" | "username">

  export type PetugasOrderByWithAggregationInput = {
    kode_petugas?: SortOrder
    nama?: SortOrder
    no_hp?: SortOrder
    username?: SortOrder
    pass?: SortOrder
    aktif?: SortOrder
    level?: SortOrder
    _count?: PetugasCountOrderByAggregateInput
    _max?: PetugasMaxOrderByAggregateInput
    _min?: PetugasMinOrderByAggregateInput
  }

  export type PetugasScalarWhereWithAggregatesInput = {
    AND?: PetugasScalarWhereWithAggregatesInput | PetugasScalarWhereWithAggregatesInput[]
    OR?: PetugasScalarWhereWithAggregatesInput[]
    NOT?: PetugasScalarWhereWithAggregatesInput | PetugasScalarWhereWithAggregatesInput[]
    kode_petugas?: StringWithAggregatesFilter<"Petugas"> | string
    nama?: StringWithAggregatesFilter<"Petugas"> | string
    no_hp?: StringWithAggregatesFilter<"Petugas"> | string
    username?: StringWithAggregatesFilter<"Petugas"> | string
    pass?: StringWithAggregatesFilter<"Petugas"> | string
    aktif?: EnumStatusAktifWithAggregatesFilter<"Petugas"> | $Enums.StatusAktif
    level?: EnumUserLevelWithAggregatesFilter<"Petugas"> | $Enums.UserLevel
  }

  export type tbKategoriCreateInput = {
    kode_kategori: string
    nama: string
    aktif?: $Enums.StatusAktif
    barang?: tbBarangCreateNestedManyWithoutKategoriInput
  }

  export type tbKategoriUncheckedCreateInput = {
    kode_kategori: string
    nama: string
    aktif?: $Enums.StatusAktif
    barang?: tbBarangUncheckedCreateNestedManyWithoutKategoriInput
  }

  export type tbKategoriUpdateInput = {
    kode_kategori?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    barang?: tbBarangUpdateManyWithoutKategoriNestedInput
  }

  export type tbKategoriUncheckedUpdateInput = {
    kode_kategori?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    barang?: tbBarangUncheckedUpdateManyWithoutKategoriNestedInput
  }

  export type tbKategoriCreateManyInput = {
    kode_kategori: string
    nama: string
    aktif?: $Enums.StatusAktif
  }

  export type tbKategoriUpdateManyMutationInput = {
    kode_kategori?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbKategoriUncheckedUpdateManyInput = {
    kode_kategori?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbBarangCreateInput = {
    kode_barang: string
    nama_barang: string
    hargaBeli: number
    hargaEcer: number
    hargaGrosir: number
    stock: number
    stock_min: number
    barcode: string
    gambar: string
    ukuran: number
    satuan: string
    aktif?: $Enums.StatusAktif
    kategori: tbKategoriCreateNestedOneWithoutBarangInput
  }

  export type tbBarangUncheckedCreateInput = {
    kode_barang: string
    nama_barang: string
    hargaBeli: number
    hargaEcer: number
    hargaGrosir: number
    stock: number
    stock_min: number
    barcode: string
    gambar: string
    kode_kategori: string
    ukuran: number
    satuan: string
    aktif?: $Enums.StatusAktif
  }

  export type tbBarangUpdateInput = {
    kode_barang?: StringFieldUpdateOperationsInput | string
    nama_barang?: StringFieldUpdateOperationsInput | string
    hargaBeli?: IntFieldUpdateOperationsInput | number
    hargaEcer?: IntFieldUpdateOperationsInput | number
    hargaGrosir?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    stock_min?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    gambar?: StringFieldUpdateOperationsInput | string
    ukuran?: IntFieldUpdateOperationsInput | number
    satuan?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    kategori?: tbKategoriUpdateOneRequiredWithoutBarangNestedInput
  }

  export type tbBarangUncheckedUpdateInput = {
    kode_barang?: StringFieldUpdateOperationsInput | string
    nama_barang?: StringFieldUpdateOperationsInput | string
    hargaBeli?: IntFieldUpdateOperationsInput | number
    hargaEcer?: IntFieldUpdateOperationsInput | number
    hargaGrosir?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    stock_min?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    gambar?: StringFieldUpdateOperationsInput | string
    kode_kategori?: StringFieldUpdateOperationsInput | string
    ukuran?: IntFieldUpdateOperationsInput | number
    satuan?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbBarangCreateManyInput = {
    kode_barang: string
    nama_barang: string
    hargaBeli: number
    hargaEcer: number
    hargaGrosir: number
    stock: number
    stock_min: number
    barcode: string
    gambar: string
    kode_kategori: string
    ukuran: number
    satuan: string
    aktif?: $Enums.StatusAktif
  }

  export type tbBarangUpdateManyMutationInput = {
    kode_barang?: StringFieldUpdateOperationsInput | string
    nama_barang?: StringFieldUpdateOperationsInput | string
    hargaBeli?: IntFieldUpdateOperationsInput | number
    hargaEcer?: IntFieldUpdateOperationsInput | number
    hargaGrosir?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    stock_min?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    gambar?: StringFieldUpdateOperationsInput | string
    ukuran?: IntFieldUpdateOperationsInput | number
    satuan?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbBarangUncheckedUpdateManyInput = {
    kode_barang?: StringFieldUpdateOperationsInput | string
    nama_barang?: StringFieldUpdateOperationsInput | string
    hargaBeli?: IntFieldUpdateOperationsInput | number
    hargaEcer?: IntFieldUpdateOperationsInput | number
    hargaGrosir?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    stock_min?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    gambar?: StringFieldUpdateOperationsInput | string
    kode_kategori?: StringFieldUpdateOperationsInput | string
    ukuran?: IntFieldUpdateOperationsInput | number
    satuan?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbSatuanCreateInput = {
    kode_satuan: string
    nama: string
    aktif?: $Enums.StatusAktif
  }

  export type tbSatuanUncheckedCreateInput = {
    kode_satuan: string
    nama: string
    aktif?: $Enums.StatusAktif
  }

  export type tbSatuanUpdateInput = {
    kode_satuan?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbSatuanUncheckedUpdateInput = {
    kode_satuan?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbSatuanCreateManyInput = {
    kode_satuan: string
    nama: string
    aktif?: $Enums.StatusAktif
  }

  export type tbSatuanUpdateManyMutationInput = {
    kode_satuan?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbSatuanUncheckedUpdateManyInput = {
    kode_satuan?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbAnggotaCreateInput = {
    NIP: string
    Nama_Anggota?: string | null
    Nomor_rekening: string
    bank: string
    no_hp: string
    Alamat: string
    Limit_Piutang: number
    aktif?: $Enums.StatusAktif
  }

  export type tbAnggotaUncheckedCreateInput = {
    NIP: string
    Nama_Anggota?: string | null
    Nomor_rekening: string
    bank: string
    no_hp: string
    Alamat: string
    Limit_Piutang: number
    aktif?: $Enums.StatusAktif
  }

  export type tbAnggotaUpdateInput = {
    NIP?: StringFieldUpdateOperationsInput | string
    Nama_Anggota?: NullableStringFieldUpdateOperationsInput | string | null
    Nomor_rekening?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    no_hp?: StringFieldUpdateOperationsInput | string
    Alamat?: StringFieldUpdateOperationsInput | string
    Limit_Piutang?: IntFieldUpdateOperationsInput | number
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbAnggotaUncheckedUpdateInput = {
    NIP?: StringFieldUpdateOperationsInput | string
    Nama_Anggota?: NullableStringFieldUpdateOperationsInput | string | null
    Nomor_rekening?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    no_hp?: StringFieldUpdateOperationsInput | string
    Alamat?: StringFieldUpdateOperationsInput | string
    Limit_Piutang?: IntFieldUpdateOperationsInput | number
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbAnggotaCreateManyInput = {
    NIP: string
    Nama_Anggota?: string | null
    Nomor_rekening: string
    bank: string
    no_hp: string
    Alamat: string
    Limit_Piutang: number
    aktif?: $Enums.StatusAktif
  }

  export type tbAnggotaUpdateManyMutationInput = {
    NIP?: StringFieldUpdateOperationsInput | string
    Nama_Anggota?: NullableStringFieldUpdateOperationsInput | string | null
    Nomor_rekening?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    no_hp?: StringFieldUpdateOperationsInput | string
    Alamat?: StringFieldUpdateOperationsInput | string
    Limit_Piutang?: IntFieldUpdateOperationsInput | number
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbAnggotaUncheckedUpdateManyInput = {
    NIP?: StringFieldUpdateOperationsInput | string
    Nama_Anggota?: NullableStringFieldUpdateOperationsInput | string | null
    Nomor_rekening?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    no_hp?: StringFieldUpdateOperationsInput | string
    Alamat?: StringFieldUpdateOperationsInput | string
    Limit_Piutang?: IntFieldUpdateOperationsInput | number
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbDetail_PengurusCreateInput = {
    kode_detail: string
    tahun: number
    nip: string
    tgl_menjabat: Date | string
    tgl_akhirmenjabat: Date | string
    tunjangan?: Decimal | DecimalJsLike | number | string | null
    aktif?: $Enums.StatusAktif
    pengurus: tbPengurusCreateNestedOneWithoutDetail_pengurusInput
  }

  export type tbDetail_PengurusUncheckedCreateInput = {
    kode_detail: string
    tahun: number
    nip: string
    kode_pengurus: string
    tgl_menjabat: Date | string
    tgl_akhirmenjabat: Date | string
    tunjangan?: Decimal | DecimalJsLike | number | string | null
    aktif?: $Enums.StatusAktif
  }

  export type tbDetail_PengurusUpdateInput = {
    kode_detail?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    nip?: StringFieldUpdateOperationsInput | string
    tgl_menjabat?: DateTimeFieldUpdateOperationsInput | Date | string
    tgl_akhirmenjabat?: DateTimeFieldUpdateOperationsInput | Date | string
    tunjangan?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    pengurus?: tbPengurusUpdateOneRequiredWithoutDetail_pengurusNestedInput
  }

  export type tbDetail_PengurusUncheckedUpdateInput = {
    kode_detail?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    nip?: StringFieldUpdateOperationsInput | string
    kode_pengurus?: StringFieldUpdateOperationsInput | string
    tgl_menjabat?: DateTimeFieldUpdateOperationsInput | Date | string
    tgl_akhirmenjabat?: DateTimeFieldUpdateOperationsInput | Date | string
    tunjangan?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbDetail_PengurusCreateManyInput = {
    kode_detail: string
    tahun: number
    nip: string
    kode_pengurus: string
    tgl_menjabat: Date | string
    tgl_akhirmenjabat: Date | string
    tunjangan?: Decimal | DecimalJsLike | number | string | null
    aktif?: $Enums.StatusAktif
  }

  export type tbDetail_PengurusUpdateManyMutationInput = {
    kode_detail?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    nip?: StringFieldUpdateOperationsInput | string
    tgl_menjabat?: DateTimeFieldUpdateOperationsInput | Date | string
    tgl_akhirmenjabat?: DateTimeFieldUpdateOperationsInput | Date | string
    tunjangan?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbDetail_PengurusUncheckedUpdateManyInput = {
    kode_detail?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    nip?: StringFieldUpdateOperationsInput | string
    kode_pengurus?: StringFieldUpdateOperationsInput | string
    tgl_menjabat?: DateTimeFieldUpdateOperationsInput | Date | string
    tgl_akhirmenjabat?: DateTimeFieldUpdateOperationsInput | Date | string
    tunjangan?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbPengurusCreateInput = {
    kode_pengurus: string
    nama: string
    aktif?: $Enums.StatusAktif
    detail_pengurus?: tbDetail_PengurusCreateNestedManyWithoutPengurusInput
  }

  export type tbPengurusUncheckedCreateInput = {
    kode_pengurus: string
    nama: string
    aktif?: $Enums.StatusAktif
    detail_pengurus?: tbDetail_PengurusUncheckedCreateNestedManyWithoutPengurusInput
  }

  export type tbPengurusUpdateInput = {
    kode_pengurus?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    detail_pengurus?: tbDetail_PengurusUpdateManyWithoutPengurusNestedInput
  }

  export type tbPengurusUncheckedUpdateInput = {
    kode_pengurus?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    detail_pengurus?: tbDetail_PengurusUncheckedUpdateManyWithoutPengurusNestedInput
  }

  export type tbPengurusCreateManyInput = {
    kode_pengurus: string
    nama: string
    aktif?: $Enums.StatusAktif
  }

  export type tbPengurusUpdateManyMutationInput = {
    kode_pengurus?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbPengurusUncheckedUpdateManyInput = {
    kode_pengurus?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type SupplierCreateInput = {
    kode_sup: string
    nama: string
    alamat: string
    no_HP: string
    perusahaan: string
    aktif: $Enums.StatusAktif
  }

  export type SupplierUncheckedCreateInput = {
    kode_sup: string
    nama: string
    alamat: string
    no_HP: string
    perusahaan: string
    aktif: $Enums.StatusAktif
  }

  export type SupplierUpdateInput = {
    kode_sup?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    no_HP?: StringFieldUpdateOperationsInput | string
    perusahaan?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type SupplierUncheckedUpdateInput = {
    kode_sup?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    no_HP?: StringFieldUpdateOperationsInput | string
    perusahaan?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type SupplierCreateManyInput = {
    kode_sup: string
    nama: string
    alamat: string
    no_HP: string
    perusahaan: string
    aktif: $Enums.StatusAktif
  }

  export type SupplierUpdateManyMutationInput = {
    kode_sup?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    no_HP?: StringFieldUpdateOperationsInput | string
    perusahaan?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type SupplierUncheckedUpdateManyInput = {
    kode_sup?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    no_HP?: StringFieldUpdateOperationsInput | string
    perusahaan?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type PetugasCreateInput = {
    kode_petugas: string
    nama: string
    no_hp: string
    username: string
    pass: string
    aktif: $Enums.StatusAktif
    level: $Enums.UserLevel
  }

  export type PetugasUncheckedCreateInput = {
    kode_petugas: string
    nama: string
    no_hp: string
    username: string
    pass: string
    aktif: $Enums.StatusAktif
    level: $Enums.UserLevel
  }

  export type PetugasUpdateInput = {
    kode_petugas?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    no_hp?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    pass?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
  }

  export type PetugasUncheckedUpdateInput = {
    kode_petugas?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    no_hp?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    pass?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
  }

  export type PetugasCreateManyInput = {
    kode_petugas: string
    nama: string
    no_hp: string
    username: string
    pass: string
    aktif: $Enums.StatusAktif
    level: $Enums.UserLevel
  }

  export type PetugasUpdateManyMutationInput = {
    kode_petugas?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    no_hp?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    pass?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
  }

  export type PetugasUncheckedUpdateManyInput = {
    kode_petugas?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    no_hp?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    pass?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumStatusAktifFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusAktif | EnumStatusAktifFieldRefInput<$PrismaModel>
    in?: $Enums.StatusAktif[]
    notIn?: $Enums.StatusAktif[]
    not?: NestedEnumStatusAktifFilter<$PrismaModel> | $Enums.StatusAktif
  }

  export type TbBarangListRelationFilter = {
    every?: tbBarangWhereInput
    some?: tbBarangWhereInput
    none?: tbBarangWhereInput
  }

  export type tbBarangOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tbKategoriOrderByRelevanceInput = {
    fields: tbKategoriOrderByRelevanceFieldEnum | tbKategoriOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tbKategoriCountOrderByAggregateInput = {
    kode_kategori?: SortOrder
    nama?: SortOrder
    aktif?: SortOrder
  }

  export type tbKategoriMaxOrderByAggregateInput = {
    kode_kategori?: SortOrder
    nama?: SortOrder
    aktif?: SortOrder
  }

  export type tbKategoriMinOrderByAggregateInput = {
    kode_kategori?: SortOrder
    nama?: SortOrder
    aktif?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumStatusAktifWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusAktif | EnumStatusAktifFieldRefInput<$PrismaModel>
    in?: $Enums.StatusAktif[]
    notIn?: $Enums.StatusAktif[]
    not?: NestedEnumStatusAktifWithAggregatesFilter<$PrismaModel> | $Enums.StatusAktif
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusAktifFilter<$PrismaModel>
    _max?: NestedEnumStatusAktifFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TbKategoriScalarRelationFilter = {
    is?: tbKategoriWhereInput
    isNot?: tbKategoriWhereInput
  }

  export type tbBarangOrderByRelevanceInput = {
    fields: tbBarangOrderByRelevanceFieldEnum | tbBarangOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tbBarangCountOrderByAggregateInput = {
    kode_barang?: SortOrder
    nama_barang?: SortOrder
    hargaBeli?: SortOrder
    hargaEcer?: SortOrder
    hargaGrosir?: SortOrder
    stock?: SortOrder
    stock_min?: SortOrder
    barcode?: SortOrder
    gambar?: SortOrder
    kode_kategori?: SortOrder
    ukuran?: SortOrder
    satuan?: SortOrder
    aktif?: SortOrder
  }

  export type tbBarangAvgOrderByAggregateInput = {
    hargaBeli?: SortOrder
    hargaEcer?: SortOrder
    hargaGrosir?: SortOrder
    stock?: SortOrder
    stock_min?: SortOrder
    ukuran?: SortOrder
  }

  export type tbBarangMaxOrderByAggregateInput = {
    kode_barang?: SortOrder
    nama_barang?: SortOrder
    hargaBeli?: SortOrder
    hargaEcer?: SortOrder
    hargaGrosir?: SortOrder
    stock?: SortOrder
    stock_min?: SortOrder
    barcode?: SortOrder
    gambar?: SortOrder
    kode_kategori?: SortOrder
    ukuran?: SortOrder
    satuan?: SortOrder
    aktif?: SortOrder
  }

  export type tbBarangMinOrderByAggregateInput = {
    kode_barang?: SortOrder
    nama_barang?: SortOrder
    hargaBeli?: SortOrder
    hargaEcer?: SortOrder
    hargaGrosir?: SortOrder
    stock?: SortOrder
    stock_min?: SortOrder
    barcode?: SortOrder
    gambar?: SortOrder
    kode_kategori?: SortOrder
    ukuran?: SortOrder
    satuan?: SortOrder
    aktif?: SortOrder
  }

  export type tbBarangSumOrderByAggregateInput = {
    hargaBeli?: SortOrder
    hargaEcer?: SortOrder
    hargaGrosir?: SortOrder
    stock?: SortOrder
    stock_min?: SortOrder
    ukuran?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type tbSatuanOrderByRelevanceInput = {
    fields: tbSatuanOrderByRelevanceFieldEnum | tbSatuanOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tbSatuanCountOrderByAggregateInput = {
    kode_satuan?: SortOrder
    nama?: SortOrder
    aktif?: SortOrder
  }

  export type tbSatuanMaxOrderByAggregateInput = {
    kode_satuan?: SortOrder
    nama?: SortOrder
    aktif?: SortOrder
  }

  export type tbSatuanMinOrderByAggregateInput = {
    kode_satuan?: SortOrder
    nama?: SortOrder
    aktif?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type tbAnggotaOrderByRelevanceInput = {
    fields: tbAnggotaOrderByRelevanceFieldEnum | tbAnggotaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tbAnggotaCountOrderByAggregateInput = {
    NIP?: SortOrder
    Nama_Anggota?: SortOrder
    Nomor_rekening?: SortOrder
    bank?: SortOrder
    no_hp?: SortOrder
    Alamat?: SortOrder
    Limit_Piutang?: SortOrder
    aktif?: SortOrder
  }

  export type tbAnggotaAvgOrderByAggregateInput = {
    Limit_Piutang?: SortOrder
  }

  export type tbAnggotaMaxOrderByAggregateInput = {
    NIP?: SortOrder
    Nama_Anggota?: SortOrder
    Nomor_rekening?: SortOrder
    bank?: SortOrder
    no_hp?: SortOrder
    Alamat?: SortOrder
    Limit_Piutang?: SortOrder
    aktif?: SortOrder
  }

  export type tbAnggotaMinOrderByAggregateInput = {
    NIP?: SortOrder
    Nama_Anggota?: SortOrder
    Nomor_rekening?: SortOrder
    bank?: SortOrder
    no_hp?: SortOrder
    Alamat?: SortOrder
    Limit_Piutang?: SortOrder
    aktif?: SortOrder
  }

  export type tbAnggotaSumOrderByAggregateInput = {
    Limit_Piutang?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type TbPengurusScalarRelationFilter = {
    is?: tbPengurusWhereInput
    isNot?: tbPengurusWhereInput
  }

  export type tbDetail_PengurusOrderByRelevanceInput = {
    fields: tbDetail_PengurusOrderByRelevanceFieldEnum | tbDetail_PengurusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tbDetail_PengurusCountOrderByAggregateInput = {
    kode_detail?: SortOrder
    tahun?: SortOrder
    nip?: SortOrder
    kode_pengurus?: SortOrder
    tgl_menjabat?: SortOrder
    tgl_akhirmenjabat?: SortOrder
    tunjangan?: SortOrder
    aktif?: SortOrder
  }

  export type tbDetail_PengurusAvgOrderByAggregateInput = {
    tahun?: SortOrder
    tunjangan?: SortOrder
  }

  export type tbDetail_PengurusMaxOrderByAggregateInput = {
    kode_detail?: SortOrder
    tahun?: SortOrder
    nip?: SortOrder
    kode_pengurus?: SortOrder
    tgl_menjabat?: SortOrder
    tgl_akhirmenjabat?: SortOrder
    tunjangan?: SortOrder
    aktif?: SortOrder
  }

  export type tbDetail_PengurusMinOrderByAggregateInput = {
    kode_detail?: SortOrder
    tahun?: SortOrder
    nip?: SortOrder
    kode_pengurus?: SortOrder
    tgl_menjabat?: SortOrder
    tgl_akhirmenjabat?: SortOrder
    tunjangan?: SortOrder
    aktif?: SortOrder
  }

  export type tbDetail_PengurusSumOrderByAggregateInput = {
    tahun?: SortOrder
    tunjangan?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type TbDetail_PengurusListRelationFilter = {
    every?: tbDetail_PengurusWhereInput
    some?: tbDetail_PengurusWhereInput
    none?: tbDetail_PengurusWhereInput
  }

  export type tbDetail_PengurusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tbPengurusOrderByRelevanceInput = {
    fields: tbPengurusOrderByRelevanceFieldEnum | tbPengurusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tbPengurusCountOrderByAggregateInput = {
    kode_pengurus?: SortOrder
    nama?: SortOrder
    aktif?: SortOrder
  }

  export type tbPengurusMaxOrderByAggregateInput = {
    kode_pengurus?: SortOrder
    nama?: SortOrder
    aktif?: SortOrder
  }

  export type tbPengurusMinOrderByAggregateInput = {
    kode_pengurus?: SortOrder
    nama?: SortOrder
    aktif?: SortOrder
  }

  export type SupplierOrderByRelevanceInput = {
    fields: SupplierOrderByRelevanceFieldEnum | SupplierOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SupplierCountOrderByAggregateInput = {
    kode_sup?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    no_HP?: SortOrder
    perusahaan?: SortOrder
    aktif?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    kode_sup?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    no_HP?: SortOrder
    perusahaan?: SortOrder
    aktif?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    kode_sup?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    no_HP?: SortOrder
    perusahaan?: SortOrder
    aktif?: SortOrder
  }

  export type EnumUserLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLevel | EnumUserLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UserLevel[]
    notIn?: $Enums.UserLevel[]
    not?: NestedEnumUserLevelFilter<$PrismaModel> | $Enums.UserLevel
  }

  export type PetugasOrderByRelevanceInput = {
    fields: PetugasOrderByRelevanceFieldEnum | PetugasOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PetugasCountOrderByAggregateInput = {
    kode_petugas?: SortOrder
    nama?: SortOrder
    no_hp?: SortOrder
    username?: SortOrder
    pass?: SortOrder
    aktif?: SortOrder
    level?: SortOrder
  }

  export type PetugasMaxOrderByAggregateInput = {
    kode_petugas?: SortOrder
    nama?: SortOrder
    no_hp?: SortOrder
    username?: SortOrder
    pass?: SortOrder
    aktif?: SortOrder
    level?: SortOrder
  }

  export type PetugasMinOrderByAggregateInput = {
    kode_petugas?: SortOrder
    nama?: SortOrder
    no_hp?: SortOrder
    username?: SortOrder
    pass?: SortOrder
    aktif?: SortOrder
    level?: SortOrder
  }

  export type EnumUserLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLevel | EnumUserLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UserLevel[]
    notIn?: $Enums.UserLevel[]
    not?: NestedEnumUserLevelWithAggregatesFilter<$PrismaModel> | $Enums.UserLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserLevelFilter<$PrismaModel>
    _max?: NestedEnumUserLevelFilter<$PrismaModel>
  }

  export type tbBarangCreateNestedManyWithoutKategoriInput = {
    create?: XOR<tbBarangCreateWithoutKategoriInput, tbBarangUncheckedCreateWithoutKategoriInput> | tbBarangCreateWithoutKategoriInput[] | tbBarangUncheckedCreateWithoutKategoriInput[]
    connectOrCreate?: tbBarangCreateOrConnectWithoutKategoriInput | tbBarangCreateOrConnectWithoutKategoriInput[]
    createMany?: tbBarangCreateManyKategoriInputEnvelope
    connect?: tbBarangWhereUniqueInput | tbBarangWhereUniqueInput[]
  }

  export type tbBarangUncheckedCreateNestedManyWithoutKategoriInput = {
    create?: XOR<tbBarangCreateWithoutKategoriInput, tbBarangUncheckedCreateWithoutKategoriInput> | tbBarangCreateWithoutKategoriInput[] | tbBarangUncheckedCreateWithoutKategoriInput[]
    connectOrCreate?: tbBarangCreateOrConnectWithoutKategoriInput | tbBarangCreateOrConnectWithoutKategoriInput[]
    createMany?: tbBarangCreateManyKategoriInputEnvelope
    connect?: tbBarangWhereUniqueInput | tbBarangWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumStatusAktifFieldUpdateOperationsInput = {
    set?: $Enums.StatusAktif
  }

  export type tbBarangUpdateManyWithoutKategoriNestedInput = {
    create?: XOR<tbBarangCreateWithoutKategoriInput, tbBarangUncheckedCreateWithoutKategoriInput> | tbBarangCreateWithoutKategoriInput[] | tbBarangUncheckedCreateWithoutKategoriInput[]
    connectOrCreate?: tbBarangCreateOrConnectWithoutKategoriInput | tbBarangCreateOrConnectWithoutKategoriInput[]
    upsert?: tbBarangUpsertWithWhereUniqueWithoutKategoriInput | tbBarangUpsertWithWhereUniqueWithoutKategoriInput[]
    createMany?: tbBarangCreateManyKategoriInputEnvelope
    set?: tbBarangWhereUniqueInput | tbBarangWhereUniqueInput[]
    disconnect?: tbBarangWhereUniqueInput | tbBarangWhereUniqueInput[]
    delete?: tbBarangWhereUniqueInput | tbBarangWhereUniqueInput[]
    connect?: tbBarangWhereUniqueInput | tbBarangWhereUniqueInput[]
    update?: tbBarangUpdateWithWhereUniqueWithoutKategoriInput | tbBarangUpdateWithWhereUniqueWithoutKategoriInput[]
    updateMany?: tbBarangUpdateManyWithWhereWithoutKategoriInput | tbBarangUpdateManyWithWhereWithoutKategoriInput[]
    deleteMany?: tbBarangScalarWhereInput | tbBarangScalarWhereInput[]
  }

  export type tbBarangUncheckedUpdateManyWithoutKategoriNestedInput = {
    create?: XOR<tbBarangCreateWithoutKategoriInput, tbBarangUncheckedCreateWithoutKategoriInput> | tbBarangCreateWithoutKategoriInput[] | tbBarangUncheckedCreateWithoutKategoriInput[]
    connectOrCreate?: tbBarangCreateOrConnectWithoutKategoriInput | tbBarangCreateOrConnectWithoutKategoriInput[]
    upsert?: tbBarangUpsertWithWhereUniqueWithoutKategoriInput | tbBarangUpsertWithWhereUniqueWithoutKategoriInput[]
    createMany?: tbBarangCreateManyKategoriInputEnvelope
    set?: tbBarangWhereUniqueInput | tbBarangWhereUniqueInput[]
    disconnect?: tbBarangWhereUniqueInput | tbBarangWhereUniqueInput[]
    delete?: tbBarangWhereUniqueInput | tbBarangWhereUniqueInput[]
    connect?: tbBarangWhereUniqueInput | tbBarangWhereUniqueInput[]
    update?: tbBarangUpdateWithWhereUniqueWithoutKategoriInput | tbBarangUpdateWithWhereUniqueWithoutKategoriInput[]
    updateMany?: tbBarangUpdateManyWithWhereWithoutKategoriInput | tbBarangUpdateManyWithWhereWithoutKategoriInput[]
    deleteMany?: tbBarangScalarWhereInput | tbBarangScalarWhereInput[]
  }

  export type tbKategoriCreateNestedOneWithoutBarangInput = {
    create?: XOR<tbKategoriCreateWithoutBarangInput, tbKategoriUncheckedCreateWithoutBarangInput>
    connectOrCreate?: tbKategoriCreateOrConnectWithoutBarangInput
    connect?: tbKategoriWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type tbKategoriUpdateOneRequiredWithoutBarangNestedInput = {
    create?: XOR<tbKategoriCreateWithoutBarangInput, tbKategoriUncheckedCreateWithoutBarangInput>
    connectOrCreate?: tbKategoriCreateOrConnectWithoutBarangInput
    upsert?: tbKategoriUpsertWithoutBarangInput
    connect?: tbKategoriWhereUniqueInput
    update?: XOR<XOR<tbKategoriUpdateToOneWithWhereWithoutBarangInput, tbKategoriUpdateWithoutBarangInput>, tbKategoriUncheckedUpdateWithoutBarangInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type tbPengurusCreateNestedOneWithoutDetail_pengurusInput = {
    create?: XOR<tbPengurusCreateWithoutDetail_pengurusInput, tbPengurusUncheckedCreateWithoutDetail_pengurusInput>
    connectOrCreate?: tbPengurusCreateOrConnectWithoutDetail_pengurusInput
    connect?: tbPengurusWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type tbPengurusUpdateOneRequiredWithoutDetail_pengurusNestedInput = {
    create?: XOR<tbPengurusCreateWithoutDetail_pengurusInput, tbPengurusUncheckedCreateWithoutDetail_pengurusInput>
    connectOrCreate?: tbPengurusCreateOrConnectWithoutDetail_pengurusInput
    upsert?: tbPengurusUpsertWithoutDetail_pengurusInput
    connect?: tbPengurusWhereUniqueInput
    update?: XOR<XOR<tbPengurusUpdateToOneWithWhereWithoutDetail_pengurusInput, tbPengurusUpdateWithoutDetail_pengurusInput>, tbPengurusUncheckedUpdateWithoutDetail_pengurusInput>
  }

  export type tbDetail_PengurusCreateNestedManyWithoutPengurusInput = {
    create?: XOR<tbDetail_PengurusCreateWithoutPengurusInput, tbDetail_PengurusUncheckedCreateWithoutPengurusInput> | tbDetail_PengurusCreateWithoutPengurusInput[] | tbDetail_PengurusUncheckedCreateWithoutPengurusInput[]
    connectOrCreate?: tbDetail_PengurusCreateOrConnectWithoutPengurusInput | tbDetail_PengurusCreateOrConnectWithoutPengurusInput[]
    createMany?: tbDetail_PengurusCreateManyPengurusInputEnvelope
    connect?: tbDetail_PengurusWhereUniqueInput | tbDetail_PengurusWhereUniqueInput[]
  }

  export type tbDetail_PengurusUncheckedCreateNestedManyWithoutPengurusInput = {
    create?: XOR<tbDetail_PengurusCreateWithoutPengurusInput, tbDetail_PengurusUncheckedCreateWithoutPengurusInput> | tbDetail_PengurusCreateWithoutPengurusInput[] | tbDetail_PengurusUncheckedCreateWithoutPengurusInput[]
    connectOrCreate?: tbDetail_PengurusCreateOrConnectWithoutPengurusInput | tbDetail_PengurusCreateOrConnectWithoutPengurusInput[]
    createMany?: tbDetail_PengurusCreateManyPengurusInputEnvelope
    connect?: tbDetail_PengurusWhereUniqueInput | tbDetail_PengurusWhereUniqueInput[]
  }

  export type tbDetail_PengurusUpdateManyWithoutPengurusNestedInput = {
    create?: XOR<tbDetail_PengurusCreateWithoutPengurusInput, tbDetail_PengurusUncheckedCreateWithoutPengurusInput> | tbDetail_PengurusCreateWithoutPengurusInput[] | tbDetail_PengurusUncheckedCreateWithoutPengurusInput[]
    connectOrCreate?: tbDetail_PengurusCreateOrConnectWithoutPengurusInput | tbDetail_PengurusCreateOrConnectWithoutPengurusInput[]
    upsert?: tbDetail_PengurusUpsertWithWhereUniqueWithoutPengurusInput | tbDetail_PengurusUpsertWithWhereUniqueWithoutPengurusInput[]
    createMany?: tbDetail_PengurusCreateManyPengurusInputEnvelope
    set?: tbDetail_PengurusWhereUniqueInput | tbDetail_PengurusWhereUniqueInput[]
    disconnect?: tbDetail_PengurusWhereUniqueInput | tbDetail_PengurusWhereUniqueInput[]
    delete?: tbDetail_PengurusWhereUniqueInput | tbDetail_PengurusWhereUniqueInput[]
    connect?: tbDetail_PengurusWhereUniqueInput | tbDetail_PengurusWhereUniqueInput[]
    update?: tbDetail_PengurusUpdateWithWhereUniqueWithoutPengurusInput | tbDetail_PengurusUpdateWithWhereUniqueWithoutPengurusInput[]
    updateMany?: tbDetail_PengurusUpdateManyWithWhereWithoutPengurusInput | tbDetail_PengurusUpdateManyWithWhereWithoutPengurusInput[]
    deleteMany?: tbDetail_PengurusScalarWhereInput | tbDetail_PengurusScalarWhereInput[]
  }

  export type tbDetail_PengurusUncheckedUpdateManyWithoutPengurusNestedInput = {
    create?: XOR<tbDetail_PengurusCreateWithoutPengurusInput, tbDetail_PengurusUncheckedCreateWithoutPengurusInput> | tbDetail_PengurusCreateWithoutPengurusInput[] | tbDetail_PengurusUncheckedCreateWithoutPengurusInput[]
    connectOrCreate?: tbDetail_PengurusCreateOrConnectWithoutPengurusInput | tbDetail_PengurusCreateOrConnectWithoutPengurusInput[]
    upsert?: tbDetail_PengurusUpsertWithWhereUniqueWithoutPengurusInput | tbDetail_PengurusUpsertWithWhereUniqueWithoutPengurusInput[]
    createMany?: tbDetail_PengurusCreateManyPengurusInputEnvelope
    set?: tbDetail_PengurusWhereUniqueInput | tbDetail_PengurusWhereUniqueInput[]
    disconnect?: tbDetail_PengurusWhereUniqueInput | tbDetail_PengurusWhereUniqueInput[]
    delete?: tbDetail_PengurusWhereUniqueInput | tbDetail_PengurusWhereUniqueInput[]
    connect?: tbDetail_PengurusWhereUniqueInput | tbDetail_PengurusWhereUniqueInput[]
    update?: tbDetail_PengurusUpdateWithWhereUniqueWithoutPengurusInput | tbDetail_PengurusUpdateWithWhereUniqueWithoutPengurusInput[]
    updateMany?: tbDetail_PengurusUpdateManyWithWhereWithoutPengurusInput | tbDetail_PengurusUpdateManyWithWhereWithoutPengurusInput[]
    deleteMany?: tbDetail_PengurusScalarWhereInput | tbDetail_PengurusScalarWhereInput[]
  }

  export type EnumUserLevelFieldUpdateOperationsInput = {
    set?: $Enums.UserLevel
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumStatusAktifFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusAktif | EnumStatusAktifFieldRefInput<$PrismaModel>
    in?: $Enums.StatusAktif[]
    notIn?: $Enums.StatusAktif[]
    not?: NestedEnumStatusAktifFilter<$PrismaModel> | $Enums.StatusAktif
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumStatusAktifWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusAktif | EnumStatusAktifFieldRefInput<$PrismaModel>
    in?: $Enums.StatusAktif[]
    notIn?: $Enums.StatusAktif[]
    not?: NestedEnumStatusAktifWithAggregatesFilter<$PrismaModel> | $Enums.StatusAktif
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusAktifFilter<$PrismaModel>
    _max?: NestedEnumStatusAktifFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLevel | EnumUserLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UserLevel[]
    notIn?: $Enums.UserLevel[]
    not?: NestedEnumUserLevelFilter<$PrismaModel> | $Enums.UserLevel
  }

  export type NestedEnumUserLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLevel | EnumUserLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UserLevel[]
    notIn?: $Enums.UserLevel[]
    not?: NestedEnumUserLevelWithAggregatesFilter<$PrismaModel> | $Enums.UserLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserLevelFilter<$PrismaModel>
    _max?: NestedEnumUserLevelFilter<$PrismaModel>
  }

  export type tbBarangCreateWithoutKategoriInput = {
    kode_barang: string
    nama_barang: string
    hargaBeli: number
    hargaEcer: number
    hargaGrosir: number
    stock: number
    stock_min: number
    barcode: string
    gambar: string
    ukuran: number
    satuan: string
    aktif?: $Enums.StatusAktif
  }

  export type tbBarangUncheckedCreateWithoutKategoriInput = {
    kode_barang: string
    nama_barang: string
    hargaBeli: number
    hargaEcer: number
    hargaGrosir: number
    stock: number
    stock_min: number
    barcode: string
    gambar: string
    ukuran: number
    satuan: string
    aktif?: $Enums.StatusAktif
  }

  export type tbBarangCreateOrConnectWithoutKategoriInput = {
    where: tbBarangWhereUniqueInput
    create: XOR<tbBarangCreateWithoutKategoriInput, tbBarangUncheckedCreateWithoutKategoriInput>
  }

  export type tbBarangCreateManyKategoriInputEnvelope = {
    data: tbBarangCreateManyKategoriInput | tbBarangCreateManyKategoriInput[]
    skipDuplicates?: boolean
  }

  export type tbBarangUpsertWithWhereUniqueWithoutKategoriInput = {
    where: tbBarangWhereUniqueInput
    update: XOR<tbBarangUpdateWithoutKategoriInput, tbBarangUncheckedUpdateWithoutKategoriInput>
    create: XOR<tbBarangCreateWithoutKategoriInput, tbBarangUncheckedCreateWithoutKategoriInput>
  }

  export type tbBarangUpdateWithWhereUniqueWithoutKategoriInput = {
    where: tbBarangWhereUniqueInput
    data: XOR<tbBarangUpdateWithoutKategoriInput, tbBarangUncheckedUpdateWithoutKategoriInput>
  }

  export type tbBarangUpdateManyWithWhereWithoutKategoriInput = {
    where: tbBarangScalarWhereInput
    data: XOR<tbBarangUpdateManyMutationInput, tbBarangUncheckedUpdateManyWithoutKategoriInput>
  }

  export type tbBarangScalarWhereInput = {
    AND?: tbBarangScalarWhereInput | tbBarangScalarWhereInput[]
    OR?: tbBarangScalarWhereInput[]
    NOT?: tbBarangScalarWhereInput | tbBarangScalarWhereInput[]
    kode_barang?: StringFilter<"tbBarang"> | string
    nama_barang?: StringFilter<"tbBarang"> | string
    hargaBeli?: IntFilter<"tbBarang"> | number
    hargaEcer?: IntFilter<"tbBarang"> | number
    hargaGrosir?: IntFilter<"tbBarang"> | number
    stock?: IntFilter<"tbBarang"> | number
    stock_min?: IntFilter<"tbBarang"> | number
    barcode?: StringFilter<"tbBarang"> | string
    gambar?: StringFilter<"tbBarang"> | string
    kode_kategori?: StringFilter<"tbBarang"> | string
    ukuran?: IntFilter<"tbBarang"> | number
    satuan?: StringFilter<"tbBarang"> | string
    aktif?: EnumStatusAktifFilter<"tbBarang"> | $Enums.StatusAktif
  }

  export type tbKategoriCreateWithoutBarangInput = {
    kode_kategori: string
    nama: string
    aktif?: $Enums.StatusAktif
  }

  export type tbKategoriUncheckedCreateWithoutBarangInput = {
    kode_kategori: string
    nama: string
    aktif?: $Enums.StatusAktif
  }

  export type tbKategoriCreateOrConnectWithoutBarangInput = {
    where: tbKategoriWhereUniqueInput
    create: XOR<tbKategoriCreateWithoutBarangInput, tbKategoriUncheckedCreateWithoutBarangInput>
  }

  export type tbKategoriUpsertWithoutBarangInput = {
    update: XOR<tbKategoriUpdateWithoutBarangInput, tbKategoriUncheckedUpdateWithoutBarangInput>
    create: XOR<tbKategoriCreateWithoutBarangInput, tbKategoriUncheckedCreateWithoutBarangInput>
    where?: tbKategoriWhereInput
  }

  export type tbKategoriUpdateToOneWithWhereWithoutBarangInput = {
    where?: tbKategoriWhereInput
    data: XOR<tbKategoriUpdateWithoutBarangInput, tbKategoriUncheckedUpdateWithoutBarangInput>
  }

  export type tbKategoriUpdateWithoutBarangInput = {
    kode_kategori?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbKategoriUncheckedUpdateWithoutBarangInput = {
    kode_kategori?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbPengurusCreateWithoutDetail_pengurusInput = {
    kode_pengurus: string
    nama: string
    aktif?: $Enums.StatusAktif
  }

  export type tbPengurusUncheckedCreateWithoutDetail_pengurusInput = {
    kode_pengurus: string
    nama: string
    aktif?: $Enums.StatusAktif
  }

  export type tbPengurusCreateOrConnectWithoutDetail_pengurusInput = {
    where: tbPengurusWhereUniqueInput
    create: XOR<tbPengurusCreateWithoutDetail_pengurusInput, tbPengurusUncheckedCreateWithoutDetail_pengurusInput>
  }

  export type tbPengurusUpsertWithoutDetail_pengurusInput = {
    update: XOR<tbPengurusUpdateWithoutDetail_pengurusInput, tbPengurusUncheckedUpdateWithoutDetail_pengurusInput>
    create: XOR<tbPengurusCreateWithoutDetail_pengurusInput, tbPengurusUncheckedCreateWithoutDetail_pengurusInput>
    where?: tbPengurusWhereInput
  }

  export type tbPengurusUpdateToOneWithWhereWithoutDetail_pengurusInput = {
    where?: tbPengurusWhereInput
    data: XOR<tbPengurusUpdateWithoutDetail_pengurusInput, tbPengurusUncheckedUpdateWithoutDetail_pengurusInput>
  }

  export type tbPengurusUpdateWithoutDetail_pengurusInput = {
    kode_pengurus?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbPengurusUncheckedUpdateWithoutDetail_pengurusInput = {
    kode_pengurus?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbDetail_PengurusCreateWithoutPengurusInput = {
    kode_detail: string
    tahun: number
    nip: string
    tgl_menjabat: Date | string
    tgl_akhirmenjabat: Date | string
    tunjangan?: Decimal | DecimalJsLike | number | string | null
    aktif?: $Enums.StatusAktif
  }

  export type tbDetail_PengurusUncheckedCreateWithoutPengurusInput = {
    kode_detail: string
    tahun: number
    nip: string
    tgl_menjabat: Date | string
    tgl_akhirmenjabat: Date | string
    tunjangan?: Decimal | DecimalJsLike | number | string | null
    aktif?: $Enums.StatusAktif
  }

  export type tbDetail_PengurusCreateOrConnectWithoutPengurusInput = {
    where: tbDetail_PengurusWhereUniqueInput
    create: XOR<tbDetail_PengurusCreateWithoutPengurusInput, tbDetail_PengurusUncheckedCreateWithoutPengurusInput>
  }

  export type tbDetail_PengurusCreateManyPengurusInputEnvelope = {
    data: tbDetail_PengurusCreateManyPengurusInput | tbDetail_PengurusCreateManyPengurusInput[]
    skipDuplicates?: boolean
  }

  export type tbDetail_PengurusUpsertWithWhereUniqueWithoutPengurusInput = {
    where: tbDetail_PengurusWhereUniqueInput
    update: XOR<tbDetail_PengurusUpdateWithoutPengurusInput, tbDetail_PengurusUncheckedUpdateWithoutPengurusInput>
    create: XOR<tbDetail_PengurusCreateWithoutPengurusInput, tbDetail_PengurusUncheckedCreateWithoutPengurusInput>
  }

  export type tbDetail_PengurusUpdateWithWhereUniqueWithoutPengurusInput = {
    where: tbDetail_PengurusWhereUniqueInput
    data: XOR<tbDetail_PengurusUpdateWithoutPengurusInput, tbDetail_PengurusUncheckedUpdateWithoutPengurusInput>
  }

  export type tbDetail_PengurusUpdateManyWithWhereWithoutPengurusInput = {
    where: tbDetail_PengurusScalarWhereInput
    data: XOR<tbDetail_PengurusUpdateManyMutationInput, tbDetail_PengurusUncheckedUpdateManyWithoutPengurusInput>
  }

  export type tbDetail_PengurusScalarWhereInput = {
    AND?: tbDetail_PengurusScalarWhereInput | tbDetail_PengurusScalarWhereInput[]
    OR?: tbDetail_PengurusScalarWhereInput[]
    NOT?: tbDetail_PengurusScalarWhereInput | tbDetail_PengurusScalarWhereInput[]
    kode_detail?: StringFilter<"tbDetail_Pengurus"> | string
    tahun?: IntFilter<"tbDetail_Pengurus"> | number
    nip?: StringFilter<"tbDetail_Pengurus"> | string
    kode_pengurus?: StringFilter<"tbDetail_Pengurus"> | string
    tgl_menjabat?: DateTimeFilter<"tbDetail_Pengurus"> | Date | string
    tgl_akhirmenjabat?: DateTimeFilter<"tbDetail_Pengurus"> | Date | string
    tunjangan?: DecimalNullableFilter<"tbDetail_Pengurus"> | Decimal | DecimalJsLike | number | string | null
    aktif?: EnumStatusAktifFilter<"tbDetail_Pengurus"> | $Enums.StatusAktif
  }

  export type tbBarangCreateManyKategoriInput = {
    kode_barang: string
    nama_barang: string
    hargaBeli: number
    hargaEcer: number
    hargaGrosir: number
    stock: number
    stock_min: number
    barcode: string
    gambar: string
    ukuran: number
    satuan: string
    aktif?: $Enums.StatusAktif
  }

  export type tbBarangUpdateWithoutKategoriInput = {
    kode_barang?: StringFieldUpdateOperationsInput | string
    nama_barang?: StringFieldUpdateOperationsInput | string
    hargaBeli?: IntFieldUpdateOperationsInput | number
    hargaEcer?: IntFieldUpdateOperationsInput | number
    hargaGrosir?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    stock_min?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    gambar?: StringFieldUpdateOperationsInput | string
    ukuran?: IntFieldUpdateOperationsInput | number
    satuan?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbBarangUncheckedUpdateWithoutKategoriInput = {
    kode_barang?: StringFieldUpdateOperationsInput | string
    nama_barang?: StringFieldUpdateOperationsInput | string
    hargaBeli?: IntFieldUpdateOperationsInput | number
    hargaEcer?: IntFieldUpdateOperationsInput | number
    hargaGrosir?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    stock_min?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    gambar?: StringFieldUpdateOperationsInput | string
    ukuran?: IntFieldUpdateOperationsInput | number
    satuan?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbBarangUncheckedUpdateManyWithoutKategoriInput = {
    kode_barang?: StringFieldUpdateOperationsInput | string
    nama_barang?: StringFieldUpdateOperationsInput | string
    hargaBeli?: IntFieldUpdateOperationsInput | number
    hargaEcer?: IntFieldUpdateOperationsInput | number
    hargaGrosir?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    stock_min?: IntFieldUpdateOperationsInput | number
    barcode?: StringFieldUpdateOperationsInput | string
    gambar?: StringFieldUpdateOperationsInput | string
    ukuran?: IntFieldUpdateOperationsInput | number
    satuan?: StringFieldUpdateOperationsInput | string
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbDetail_PengurusCreateManyPengurusInput = {
    kode_detail: string
    tahun: number
    nip: string
    tgl_menjabat: Date | string
    tgl_akhirmenjabat: Date | string
    tunjangan?: Decimal | DecimalJsLike | number | string | null
    aktif?: $Enums.StatusAktif
  }

  export type tbDetail_PengurusUpdateWithoutPengurusInput = {
    kode_detail?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    nip?: StringFieldUpdateOperationsInput | string
    tgl_menjabat?: DateTimeFieldUpdateOperationsInput | Date | string
    tgl_akhirmenjabat?: DateTimeFieldUpdateOperationsInput | Date | string
    tunjangan?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbDetail_PengurusUncheckedUpdateWithoutPengurusInput = {
    kode_detail?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    nip?: StringFieldUpdateOperationsInput | string
    tgl_menjabat?: DateTimeFieldUpdateOperationsInput | Date | string
    tgl_akhirmenjabat?: DateTimeFieldUpdateOperationsInput | Date | string
    tunjangan?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }

  export type tbDetail_PengurusUncheckedUpdateManyWithoutPengurusInput = {
    kode_detail?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    nip?: StringFieldUpdateOperationsInput | string
    tgl_menjabat?: DateTimeFieldUpdateOperationsInput | Date | string
    tgl_akhirmenjabat?: DateTimeFieldUpdateOperationsInput | Date | string
    tunjangan?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    aktif?: EnumStatusAktifFieldUpdateOperationsInput | $Enums.StatusAktif
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}